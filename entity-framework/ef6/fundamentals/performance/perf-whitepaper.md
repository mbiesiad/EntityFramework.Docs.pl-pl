---
title: Zagadnienia dotyczące wydajności dla EF4, EF5 i EF6-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: 07eb605f0d39f0c1bcfe781540525180f0dd0b22
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/09/2019
ms.locfileid: "72181666"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a><span data-ttu-id="4db1f-102">Zagadnienia dotyczące wydajności dla EF 4, 5 i 6</span><span class="sxs-lookup"><span data-stu-id="4db1f-102">Performance considerations for EF 4, 5, and 6</span></span>
<span data-ttu-id="4db1f-103">Przez David Obando, Eric Dettinger i inne</span><span class="sxs-lookup"><span data-stu-id="4db1f-103">By David Obando, Eric Dettinger and others</span></span>

<span data-ttu-id="4db1f-104">Publikacj Kwiecień 2012</span><span class="sxs-lookup"><span data-stu-id="4db1f-104">Published: April 2012</span></span>

<span data-ttu-id="4db1f-105">Ostatnia aktualizacja: 2014 maja</span><span class="sxs-lookup"><span data-stu-id="4db1f-105">Last updated: May 2014</span></span>

------------------------------------------------------------------------

## <a name="1-introduction"></a><span data-ttu-id="4db1f-106">1. Wprowadzenie</span><span class="sxs-lookup"><span data-stu-id="4db1f-106">1. Introduction</span></span>

<span data-ttu-id="4db1f-107">Struktury mapowania relacyjnego obiektów są wygodnym sposobem zapewnienia abstrakcji dostępu do danych w aplikacji zorientowanej obiektowo.</span><span class="sxs-lookup"><span data-stu-id="4db1f-107">Object-Relational Mapping frameworks are a convenient way to provide an abstraction for data access in an object-oriented application.</span></span> <span data-ttu-id="4db1f-108">W przypadku aplikacji .NET zalecana firma Microsoft ma Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-108">For .NET applications, Microsoft's recommended O/RM is Entity Framework.</span></span> <span data-ttu-id="4db1f-109">W przypadku jakichkolwiek streszczeń, wydajność może być istotna.</span><span class="sxs-lookup"><span data-stu-id="4db1f-109">With any abstraction though, performance can become a concern.</span></span>

<span data-ttu-id="4db1f-110">Niniejszy dokument został zapisany, aby pokazać zagadnienia dotyczące wydajności podczas tworzenia aplikacji przy użyciu Entity Framework, aby dać deweloperom pomysł Entity Framework wewnętrznych algorytmów, które mogą wpływać na wydajność, oraz zapewnić wskazówki dotyczące badania i Poprawa wydajności w aplikacjach korzystających z Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-110">This whitepaper was written to show the performance considerations when developing applications using Entity Framework, to give developers an idea of the Entity Framework internal algorithms that can affect performance, and to provide tips for investigation and improving performance in their applications that use Entity Framework.</span></span> <span data-ttu-id="4db1f-111">Istnieje kilka dobrych tematów dotyczących wydajności już dostępnych w sieci Web. Ponadto podjęto próbę przeprowadzenia tych zasobów, jeśli jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="4db1f-111">There are a number of good topics on performance already available on the web, and we've also tried pointing to these resources where possible.</span></span>

<span data-ttu-id="4db1f-112">Wydajność to Lewa sekcja.</span><span class="sxs-lookup"><span data-stu-id="4db1f-112">Performance is a tricky topic.</span></span> <span data-ttu-id="4db1f-113">Ten oficjalny dokument jest przeznaczony dla zasobów, które ułatwiają podejmowanie decyzji dotyczących wydajności dla aplikacji korzystających z Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-113">This whitepaper is intended as a resource to help you make performance related decisions for your applications that use Entity Framework.</span></span> <span data-ttu-id="4db1f-114">Dodaliśmy pewne metryki testów w celu zademonstrowania wydajności, ale te metryki nie zamierzą bezwzględnych wskaźników wydajności, które będą widoczne w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-114">We have included some test metrics to demonstrate performance, but these metrics aren't intended as absolute indicators of the performance you will see in your application.</span></span>

<span data-ttu-id="4db1f-115">W praktyce w tym dokumencie przyjęto, że Entity Framework 4 jest uruchamiany na platformie .NET 4,0 i Entity Framework 5 i 6 są uruchamiane w ramach platformy .NET 4,5.</span><span class="sxs-lookup"><span data-stu-id="4db1f-115">For practical purposes, this document assumes Entity Framework 4 is run under .NET 4.0 and Entity Framework 5 and 6 are run under .NET 4.5.</span></span> <span data-ttu-id="4db1f-116">Wiele ulepszeń wydajności Entity Framework 5 znajduje się w podstawowych składnikach dostarczanych z platformą .NET 4,5.</span><span class="sxs-lookup"><span data-stu-id="4db1f-116">Many of the performance improvements made for Entity Framework 5 reside within the core components that ship with .NET 4.5.</span></span>

<span data-ttu-id="4db1f-117">Entity Framework 6 to wersja poza pasmem i nie zależy od składników Entity Framework dostarczanych z platformą .NET.</span><span class="sxs-lookup"><span data-stu-id="4db1f-117">Entity Framework 6 is an out of band release and does not depend on the Entity Framework components that ship with .NET.</span></span> <span data-ttu-id="4db1f-118">Entity Framework 6 działa na platformach .NET 4,0 i .NET 4,5 oraz oferuje dużą wydajność dla tych, którzy nie zostali uaktualnioni z platformy .NET 4,0, ale chcą mieć najnowsze Entity Framework BITS w swojej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-118">Entity Framework 6 work on both .NET 4.0 and .NET 4.5, and can offer a big performance benefit to those who haven’t upgraded from .NET 4.0 but want the latest Entity Framework bits in their application.</span></span> <span data-ttu-id="4db1f-119">W tym dokumencie znajduje się Entity Framework 6, odnosi się do najnowszej wersji dostępnej w momencie zapisu: wersja 6.1.0.</span><span class="sxs-lookup"><span data-stu-id="4db1f-119">When this document mentions Entity Framework 6, it refers to the latest version available at the time of this writing: version 6.1.0.</span></span>

## <a name="2-cold-vs-warm-query-execution"></a><span data-ttu-id="4db1f-120">2. Zimny a Wykonywanie zapytania ciepłego</span><span class="sxs-lookup"><span data-stu-id="4db1f-120">2. Cold vs. Warm Query Execution</span></span>

<span data-ttu-id="4db1f-121">Podczas pierwszego wykonywania zapytania dotyczącego danego modelu, Entity Framework wykonuje wiele pracy w tle, aby załadować i zweryfikować model.</span><span class="sxs-lookup"><span data-stu-id="4db1f-121">The very first time any query is made against a given model, the Entity Framework does a lot of work behind the scenes to load and validate the model.</span></span> <span data-ttu-id="4db1f-122">Często odwołujemy się do pierwszego zapytania jako "zimne".</span><span class="sxs-lookup"><span data-stu-id="4db1f-122">We frequently refer to this first query as a "cold" query.</span></span><span data-ttu-id="4db1f-123">  Dalsze zapytania dotyczące już załadowanego modelu są znane jako zapytania "grzane" i są znacznie szybsze.</span><span class="sxs-lookup"><span data-stu-id="4db1f-123">  Further queries against an already loaded model are known as "warm" queries, and are much faster.</span></span>

<span data-ttu-id="4db1f-124">Przyjrzyjmy się ogólnemu w miejscu, gdzie podczas wykonywania zapytania przy użyciu Entity Framework i zobacz, w jaki sposób poprawiamy działania w Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="4db1f-124">Let’s take a high-level view of where time is spent when executing a query using Entity Framework, and see where things are improving in Entity Framework 6.</span></span>

<span data-ttu-id="4db1f-125">**Pierwsze wykonanie zapytania — zimna kwerenda**</span><span class="sxs-lookup"><span data-stu-id="4db1f-125">**First Query Execution – cold query**</span></span>

| <span data-ttu-id="4db1f-126">Kod zapisy użytkownika</span><span class="sxs-lookup"><span data-stu-id="4db1f-126">Code User Writes</span></span>                                                                                     | <span data-ttu-id="4db1f-127">Action</span><span class="sxs-lookup"><span data-stu-id="4db1f-127">Action</span></span>                    | <span data-ttu-id="4db1f-128">Wpływ na wydajność EF4</span><span class="sxs-lookup"><span data-stu-id="4db1f-128">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="4db1f-129">Wpływ na wydajność EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-129">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="4db1f-130">Wpływ na wydajność EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-130">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="4db1f-131">Tworzenie kontekstu</span><span class="sxs-lookup"><span data-stu-id="4db1f-131">Context creation</span></span>          | <span data-ttu-id="4db1f-132">Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-132">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="4db1f-133">Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-133">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="4db1f-134">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-134">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="4db1f-135">Tworzenie wyrażenia zapytania</span><span class="sxs-lookup"><span data-stu-id="4db1f-135">Query expression creation</span></span> | <span data-ttu-id="4db1f-136">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-136">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="4db1f-137">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-137">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="4db1f-138">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-138">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="4db1f-139">Wykonanie zapytania LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-139">LINQ query execution</span></span>      | <span data-ttu-id="4db1f-140">-Ładowanie metadanych: Wysoki, ale w pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-140">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="4db1f-141">-Wyświetl generowanie: Prawdopodobnie bardzo wysokie, ale w pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-141">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="4db1f-142">-Obliczanie parametrów: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-142">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="4db1f-143">-Tłumaczenie zapytania: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-143">- Query translation: Medium</span></span> <br/> <span data-ttu-id="4db1f-144">-Materializer generacji: Średni, ale buforowany</span><span class="sxs-lookup"><span data-stu-id="4db1f-144">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="4db1f-145">-Wykonywanie zapytania dotyczącego bazy danych: Potencjalnie wysoka</span><span class="sxs-lookup"><span data-stu-id="4db1f-145">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="4db1f-146">+ Połączenie. Otwórz</span><span class="sxs-lookup"><span data-stu-id="4db1f-146">+ Connection.Open</span></span> <br/> <span data-ttu-id="4db1f-147">+ Command. ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="4db1f-147">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="4db1f-148">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="4db1f-148">+ DataReader.Read</span></span> <br/> <span data-ttu-id="4db1f-149">Materializację obiektu: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-149">Object materialization: Medium</span></span> <br/> <span data-ttu-id="4db1f-150">-Wyszukiwanie tożsamości: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-150">- Identity lookup: Medium</span></span> | <span data-ttu-id="4db1f-151">-Ładowanie metadanych: Wysoki, ale w pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-151">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="4db1f-152">-Wyświetl generowanie: Prawdopodobnie bardzo wysokie, ale w pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-152">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="4db1f-153">-Obliczanie parametrów: Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-153">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="4db1f-154">-Tłumaczenie zapytania: Średni, ale buforowany</span><span class="sxs-lookup"><span data-stu-id="4db1f-154">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="4db1f-155">-Materializer generacji: Średni, ale buforowany</span><span class="sxs-lookup"><span data-stu-id="4db1f-155">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="4db1f-156">-Wykonywanie zapytania dotyczącego bazy danych: Potencjalnie wysoka (lepsze zapytania w niektórych sytuacjach)</span><span class="sxs-lookup"><span data-stu-id="4db1f-156">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="4db1f-157">+ Połączenie. Otwórz</span><span class="sxs-lookup"><span data-stu-id="4db1f-157">+ Connection.Open</span></span> <br/> <span data-ttu-id="4db1f-158">+ Command. ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="4db1f-158">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="4db1f-159">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="4db1f-159">+ DataReader.Read</span></span> <br/> <span data-ttu-id="4db1f-160">Materializację obiektu: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-160">Object materialization: Medium</span></span> <br/> <span data-ttu-id="4db1f-161">-Wyszukiwanie tożsamości: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-161">- Identity lookup: Medium</span></span> | <span data-ttu-id="4db1f-162">-Ładowanie metadanych: Wysoki, ale w pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-162">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="4db1f-163">-Wyświetl generowanie: Średni, ale buforowany</span><span class="sxs-lookup"><span data-stu-id="4db1f-163">- View generation: Medium but cached</span></span> <br/> <span data-ttu-id="4db1f-164">-Obliczanie parametrów: Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-164">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="4db1f-165">-Tłumaczenie zapytania: Średni, ale buforowany</span><span class="sxs-lookup"><span data-stu-id="4db1f-165">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="4db1f-166">-Materializer generacji: Średni, ale buforowany</span><span class="sxs-lookup"><span data-stu-id="4db1f-166">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="4db1f-167">-Wykonywanie zapytania dotyczącego bazy danych: Potencjalnie wysoka (lepsze zapytania w niektórych sytuacjach)</span><span class="sxs-lookup"><span data-stu-id="4db1f-167">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="4db1f-168">+ Połączenie. Otwórz</span><span class="sxs-lookup"><span data-stu-id="4db1f-168">+ Connection.Open</span></span> <br/> <span data-ttu-id="4db1f-169">+ Command. ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="4db1f-169">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="4db1f-170">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="4db1f-170">+ DataReader.Read</span></span> <br/> <span data-ttu-id="4db1f-171">Materializację obiektu: Średni (szybszy niż EF5)</span><span class="sxs-lookup"><span data-stu-id="4db1f-171">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="4db1f-172">-Wyszukiwanie tożsamości: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-172">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="4db1f-173">Połączenie. Zamknij</span><span class="sxs-lookup"><span data-stu-id="4db1f-173">Connection.Close</span></span>          | <span data-ttu-id="4db1f-174">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-174">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="4db1f-175">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-175">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="4db1f-176">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-176">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


<span data-ttu-id="4db1f-177">**Drugie wykonanie zapytania — grzane zapytanie**</span><span class="sxs-lookup"><span data-stu-id="4db1f-177">**Second Query Execution – warm query**</span></span>

| <span data-ttu-id="4db1f-178">Kod zapisy użytkownika</span><span class="sxs-lookup"><span data-stu-id="4db1f-178">Code User Writes</span></span>                                                                                     | <span data-ttu-id="4db1f-179">Action</span><span class="sxs-lookup"><span data-stu-id="4db1f-179">Action</span></span>                    | <span data-ttu-id="4db1f-180">Wpływ na wydajność EF4</span><span class="sxs-lookup"><span data-stu-id="4db1f-180">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="4db1f-181">Wpływ na wydajność EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-181">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="4db1f-182">Wpływ na wydajność EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-182">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="4db1f-183">Tworzenie kontekstu</span><span class="sxs-lookup"><span data-stu-id="4db1f-183">Context creation</span></span>          | <span data-ttu-id="4db1f-184">Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-184">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="4db1f-185">Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-185">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="4db1f-186">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-186">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="4db1f-187">Tworzenie wyrażenia zapytania</span><span class="sxs-lookup"><span data-stu-id="4db1f-187">Query expression creation</span></span> | <span data-ttu-id="4db1f-188">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-188">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="4db1f-189">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-189">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="4db1f-190">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-190">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="4db1f-191">Wykonanie zapytania LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-191">LINQ query execution</span></span>      | <span data-ttu-id="4db1f-192">-Wyszukiwanie ~~ładowania~~ metadanych: ~~Wysoki, ale w pamięci podręcznej~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-192">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-193">-Wyszukiwanie ~~generowania~~ widoku: ~~Prawdopodobnie bardzo wysokie, ale w pamięci podręcznej~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-193">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-194">-Obliczanie parametrów: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-194">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="4db1f-195">-Wyszukiwanie ~~tłumaczenia~~ zapytania: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-195">- Query ~~translation~~ lookup: Medium</span></span> <br/> <span data-ttu-id="4db1f-196">-Materializer ~~generacji~~ : ~~Średni, ale buforowany~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-196">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-197">-Wykonywanie zapytania dotyczącego bazy danych: Potencjalnie wysoka</span><span class="sxs-lookup"><span data-stu-id="4db1f-197">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="4db1f-198">+ Połączenie. Otwórz</span><span class="sxs-lookup"><span data-stu-id="4db1f-198">+ Connection.Open</span></span> <br/> <span data-ttu-id="4db1f-199">+ Command. ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="4db1f-199">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="4db1f-200">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="4db1f-200">+ DataReader.Read</span></span> <br/> <span data-ttu-id="4db1f-201">Materializację obiektu: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-201">Object materialization: Medium</span></span> <br/> <span data-ttu-id="4db1f-202">-Wyszukiwanie tożsamości: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-202">- Identity lookup: Medium</span></span> | <span data-ttu-id="4db1f-203">-Wyszukiwanie ~~ładowania~~ metadanych: ~~Wysoki, ale w pamięci podręcznej~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-203">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-204">-Wyszukiwanie ~~generowania~~ widoku: ~~Prawdopodobnie bardzo wysokie, ale w pamięci podręcznej~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-204">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-205">-Obliczanie parametrów: Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-205">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="4db1f-206">-Wyszukiwanie ~~tłumaczenia~~ zapytania: ~~Średni, ale buforowany~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-206">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-207">-Materializer ~~generacji~~ : ~~Średni, ale buforowany~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-207">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-208">-Wykonywanie zapytania dotyczącego bazy danych: Potencjalnie wysoka (lepsze zapytania w niektórych sytuacjach)</span><span class="sxs-lookup"><span data-stu-id="4db1f-208">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="4db1f-209">+ Połączenie. Otwórz</span><span class="sxs-lookup"><span data-stu-id="4db1f-209">+ Connection.Open</span></span> <br/> <span data-ttu-id="4db1f-210">+ Command. ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="4db1f-210">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="4db1f-211">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="4db1f-211">+ DataReader.Read</span></span> <br/> <span data-ttu-id="4db1f-212">Materializację obiektu: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-212">Object materialization: Medium</span></span> <br/> <span data-ttu-id="4db1f-213">-Wyszukiwanie tożsamości: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-213">- Identity lookup: Medium</span></span> | <span data-ttu-id="4db1f-214">-Wyszukiwanie ~~ładowania~~ metadanych: ~~Wysoki, ale w pamięci podręcznej~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-214">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-215">-Wyszukiwanie ~~generowania~~ widoku: ~~Średni, ale buforowany~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-215">- View ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-216">-Obliczanie parametrów: Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-216">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="4db1f-217">-Wyszukiwanie ~~tłumaczenia~~ zapytania: ~~Średni, ale buforowany~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-217">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-218">-Materializer ~~generacji~~ : ~~Średni, ale buforowany~~ Małą</span><span class="sxs-lookup"><span data-stu-id="4db1f-218">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="4db1f-219">-Wykonywanie zapytania dotyczącego bazy danych: Potencjalnie wysoka (lepsze zapytania w niektórych sytuacjach)</span><span class="sxs-lookup"><span data-stu-id="4db1f-219">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="4db1f-220">+ Połączenie. Otwórz</span><span class="sxs-lookup"><span data-stu-id="4db1f-220">+ Connection.Open</span></span> <br/> <span data-ttu-id="4db1f-221">+ Command. ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="4db1f-221">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="4db1f-222">+ DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="4db1f-222">+ DataReader.Read</span></span> <br/> <span data-ttu-id="4db1f-223">Materializację obiektu: Średni (szybszy niż EF5)</span><span class="sxs-lookup"><span data-stu-id="4db1f-223">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="4db1f-224">-Wyszukiwanie tożsamości: Średni</span><span class="sxs-lookup"><span data-stu-id="4db1f-224">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="4db1f-225">Połączenie. Zamknij</span><span class="sxs-lookup"><span data-stu-id="4db1f-225">Connection.Close</span></span>          | <span data-ttu-id="4db1f-226">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-226">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="4db1f-227">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-227">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="4db1f-228">Małe</span><span class="sxs-lookup"><span data-stu-id="4db1f-228">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


<span data-ttu-id="4db1f-229">Istnieje kilka sposobów zmniejszenia kosztów wydajności zarówno w przypadku zapytań zimnych, jak i ciepłej. Zapoznaj się z nimi w poniższej sekcji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-229">There are several ways to reduce the performance cost of both cold and warm queries, and we'll take a look at these in the following section.</span></span> <span data-ttu-id="4db1f-230">Zapoznaj się z tym, jak zmniejszyć koszt ładowania modelu w zimnych zapytaniach, używając wstępnie wygenerowanych widoków, które powinny pomóc w zmniejszeniu wydajności podczas generowania widoku.</span><span class="sxs-lookup"><span data-stu-id="4db1f-230">Specifically, we'll look at reducing the cost of model loading in cold queries by using pre-generated views, which should help alleviate performance pains experienced during view generation.</span></span> <span data-ttu-id="4db1f-231">W przypadku zapytań ciepłej będziemy obejmować buforowanie planu zapytania, brak zapytań śledzenia i różne opcje wykonywania zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-231">For warm queries, we'll cover query plan caching, no tracking queries, and different query execution options.</span></span>

### <a name="21-what-is-view-generation"></a><span data-ttu-id="4db1f-232">2,1 co to jest generacja widoku?</span><span class="sxs-lookup"><span data-stu-id="4db1f-232">2.1 What is View Generation?</span></span>

<span data-ttu-id="4db1f-233">Aby zrozumieć, jaka jest generacja widoku, należy najpierw zrozumieć, co to jest "widoki mapowania".</span><span class="sxs-lookup"><span data-stu-id="4db1f-233">In order to understand what view generation is, we must first understand what “Mapping Views” are.</span></span> <span data-ttu-id="4db1f-234">Widoki mapowania są wykonywalnymi reprezentacjami przekształceń określonych w mapowaniu dla każdego zestawu jednostek i skojarzenia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-234">Mapping Views are executable representations of the transformations specified in the mapping for each entity set and association.</span></span> <span data-ttu-id="4db1f-235">Wewnętrznie te widoki mapowania przyjmują kształt CQTs (kanoniczne drzewa zapytań).</span><span class="sxs-lookup"><span data-stu-id="4db1f-235">Internally, these mapping views take the shape of CQTs (canonical query trees).</span></span> <span data-ttu-id="4db1f-236">Istnieją dwa typy widoków mapowania:</span><span class="sxs-lookup"><span data-stu-id="4db1f-236">There are two types of mapping views:</span></span>

-   <span data-ttu-id="4db1f-237">Widoki zapytań: reprezentuje transformację niezbędną do przechodzenia ze schematu bazy danych do modelu koncepcyjnego.</span><span class="sxs-lookup"><span data-stu-id="4db1f-237">Query views: these represent the transformation necessary to go from the database schema to the conceptual model.</span></span>
-   <span data-ttu-id="4db1f-238">Aktualizuj widoki: reprezentuje transformację niezbędną do przechodzenia z modelu koncepcyjnego do schematu bazy danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-238">Update views: these represent the transformation necessary to go from the conceptual model to the database schema.</span></span>

<span data-ttu-id="4db1f-239">Należy pamiętać, że model koncepcyjny może się różnić od schematu bazy danych na różne sposoby.</span><span class="sxs-lookup"><span data-stu-id="4db1f-239">Keep in mind that the conceptual model might differ from the database schema in various ways.</span></span> <span data-ttu-id="4db1f-240">Na przykład jedna tabela może być używana do przechowywania danych dla dwóch różnych typów jednostek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-240">For example, one single table might be used to store the data for two different entity types.</span></span> <span data-ttu-id="4db1f-241">Dziedziczenie i nieuproszczone mapowania odgrywają rolę w złożoności widoków mapowania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-241">Inheritance and non-trivial mappings play a role in the complexity of the mapping views.</span></span>

<span data-ttu-id="4db1f-242">Proces przetwarzania tych widoków na podstawie specyfikacji mapowania to to, co wywołujemy generowanie widoku.</span><span class="sxs-lookup"><span data-stu-id="4db1f-242">The process of computing these views based on the specification of the mapping is what we call view generation.</span></span> <span data-ttu-id="4db1f-243">Generowanie widoku może być wykonywane dynamicznie podczas ładowania modelu lub w czasie kompilacji przy użyciu "wstępnie wygenerowanych widoków"; drugi z nich jest serializowany w postaci instrukcji Entity SQL do pliku C @ no__t-0 lub VB.</span><span class="sxs-lookup"><span data-stu-id="4db1f-243">View generation can either take place dynamically when a model is loaded, or at build time, by using "pre-generated views"; the latter are serialized in the form of Entity SQL statements to a C\# or VB file.</span></span>

<span data-ttu-id="4db1f-244">Po wygenerowaniu widoków są one również weryfikowane.</span><span class="sxs-lookup"><span data-stu-id="4db1f-244">When views are generated, they are also validated.</span></span> <span data-ttu-id="4db1f-245">Z punktu widzenia wydajności zdecydowana większość kosztów generowania widoku jest w rzeczywistości walidacją widoków, które zapewniają, że połączenia między jednostkami mają sens i mają prawidłową Kardynalność dla wszystkich obsługiwanych operacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-245">From a performance standpoint, the vast majority of the cost of view generation is actually the validation of the views which ensures that the connections between the entities make sense and have the correct cardinality for all the supported operations.</span></span>

<span data-ttu-id="4db1f-246">Gdy wykonywane jest zapytanie nad zestawem jednostek, zapytanie jest połączone z odpowiednim widokiem zapytania, a wynik tej kompozycji jest uruchamiany za pośrednictwem kompilatora planu, aby utworzyć reprezentację zapytania, które może zrozumieć magazyn zapasowy.</span><span class="sxs-lookup"><span data-stu-id="4db1f-246">When a query over an entity set is executed, the query is combined with the corresponding query view, and the result of this composition is run through the plan compiler to create the representation of the query that the backing store can understand.</span></span> <span data-ttu-id="4db1f-247">W przypadku SQL Server końcowy wynik tej kompilacji będzie instrukcją SELECT języka T-SQL.</span><span class="sxs-lookup"><span data-stu-id="4db1f-247">For SQL Server, the final result of this compilation will be a T-SQL SELECT statement.</span></span> <span data-ttu-id="4db1f-248">Podczas pierwszego wykonywania aktualizacji przez zestaw jednostek widok aktualizacji jest uruchamiany przez podobny proces, aby przekształcić go w Instrukcje DML dla docelowej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-248">The first time an update over an entity set is performed, the update view is run through a similar process to transform it into DML statements for the target database.</span></span>

### <a name="22-factors-that-affect-view-generation-performance"></a><span data-ttu-id="4db1f-249">2,2 czynników wpływających na wydajność generowania widoku</span><span class="sxs-lookup"><span data-stu-id="4db1f-249">2.2 Factors that affect View Generation performance</span></span>

<span data-ttu-id="4db1f-250">Krok generowania widoku wydajności nie tylko zależy od rozmiaru modelu, ale również od tego, jak jest on połączony z modelem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-250">The performance of view generation step not only depends on the size of your model but also on how interconnected the model is.</span></span> <span data-ttu-id="4db1f-251">Jeśli dwie jednostki są połączone za pośrednictwem łańcucha dziedziczenia lub skojarzenia, są one znane jako połączone.</span><span class="sxs-lookup"><span data-stu-id="4db1f-251">If two Entities are connected via an inheritance chain or an Association, they are said to be connected.</span></span> <span data-ttu-id="4db1f-252">Podobnie, jeśli dwie tabele są połączone za pośrednictwem klucza obcego, są one połączone.</span><span class="sxs-lookup"><span data-stu-id="4db1f-252">Similarly if two tables are connected via a foreign key, they are connected.</span></span> <span data-ttu-id="4db1f-253">Wraz ze wzrostem liczby połączonych jednostek i tabel w schematach zwiększa się koszt generowania widoku.</span><span class="sxs-lookup"><span data-stu-id="4db1f-253">As the number of connected Entities and tables in your schemas increase, the view generation cost increases.</span></span>

<span data-ttu-id="4db1f-254">Algorytm używany do generowania i weryfikowania widoków jest wykładniczy w najgorszym przypadku, chociaż używamy pewnych optymalizacji, aby usprawnić ten proces.</span><span class="sxs-lookup"><span data-stu-id="4db1f-254">The algorithm that we use to generate and validate views is exponential in the worst case, though we do use some optimizations to improve this.</span></span> <span data-ttu-id="4db1f-255">Największe czynniki wpływające negatywnie na wydajność są następujące:</span><span class="sxs-lookup"><span data-stu-id="4db1f-255">The biggest factors that seem to negatively affect performance are:</span></span>

-   <span data-ttu-id="4db1f-256">Rozmiar modelu, odnoszący się do liczby jednostek i ilości skojarzeń między tymi jednostkami.</span><span class="sxs-lookup"><span data-stu-id="4db1f-256">Model size, referring to the number of entities and the amount of associations between these entities.</span></span>
-   <span data-ttu-id="4db1f-257">Złożoność modelu, w tym dziedziczenie obejmujące dużą liczbę typów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-257">Model complexity, specifically inheritance involving a large number of types.</span></span>
-   <span data-ttu-id="4db1f-258">Używanie niezależnych skojarzeń zamiast skojarzeń kluczy obcych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-258">Using Independent Associations, instead of Foreign Key Associations.</span></span>

<span data-ttu-id="4db1f-259">W przypadku małych modeli prosta koszt może być wystarczająco mały, aby nie bother przy użyciu wstępnie wygenerowanych widoków.</span><span class="sxs-lookup"><span data-stu-id="4db1f-259">For small, simple models the cost may be small enough to not bother using pre-generated views.</span></span> <span data-ttu-id="4db1f-260">W miarę wzrostu rozmiaru modelu i stopnia złożoności dostępnych jest kilka opcji zmniejszania kosztów generowania i walidacji widoku.</span><span class="sxs-lookup"><span data-stu-id="4db1f-260">As model size and complexity increase, there are several options available to reduce the cost of view generation and validation.</span></span>

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a><span data-ttu-id="4db1f-261">2,3 użycie wstępnie wygenerowanych widoków w celu zmniejszenia czasu ładowania modelu</span><span class="sxs-lookup"><span data-stu-id="4db1f-261">2.3 Using Pre-Generated Views to decrease model load time</span></span>

<span data-ttu-id="4db1f-262">Aby uzyskać szczegółowe informacje na temat używania wstępnie wygenerowanych widoków w Entity Framework 6 odwiedź [wstępnie wygenerowane widoki mapowania](~/ef6/fundamentals/performance/pre-generated-views.md)</span><span class="sxs-lookup"><span data-stu-id="4db1f-262">For detailed information on how to use pre-generated views on Entity Framework 6 visit [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md)</span></span>

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a><span data-ttu-id="4db1f-263">2.3.1 wstępnie wygenerowane widoki przy użyciu Entity Framework narzędzia do zarządzania wersjami Community</span><span class="sxs-lookup"><span data-stu-id="4db1f-263">2.3.1 Pre-Generated views using the Entity Framework Power Tools Community Edition</span></span>

<span data-ttu-id="4db1f-264">Aby wygenerować widoki modeli EDMX i Code First, można użyć [wersji Community Tools programu Entity Framework 6](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) , klikając prawym przyciskiem myszy plik klasy modelu i używając menu Entity Framework, aby wybrać polecenie "Generuj widoki".</span><span class="sxs-lookup"><span data-stu-id="4db1f-264">You can use the [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) to generate views of EDMX and Code First models by right-clicking the model class file and using the Entity Framework menu to select “Generate Views”.</span></span> <span data-ttu-id="4db1f-265">Entity Framework narzędzia do zarządzania wersjami Professional działają tylko w kontekstach pochodnych DbContext.</span><span class="sxs-lookup"><span data-stu-id="4db1f-265">The Entity Framework Power Tools Community Edition work only on DbContext-derived contexts.</span></span>

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a><span data-ttu-id="4db1f-266">2.3.2 użycie wstępnie wygenerowanych widoków z modelem utworzonym przez EDMGen</span><span class="sxs-lookup"><span data-stu-id="4db1f-266">2.3.2 How to use Pre-generated views with a model created by EDMGen</span></span>

<span data-ttu-id="4db1f-267">EDMGen to narzędzie, które jest dostarczane z platformą .NET i współpracuje z Entity Framework 4 i 5, ale nie z Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="4db1f-267">EDMGen is a utility that ships with .NET and works with Entity Framework 4 and 5, but not with Entity Framework 6.</span></span> <span data-ttu-id="4db1f-268">EDMGen umożliwia wygenerowanie pliku modelu, warstwy obiektu i widoków z wiersza polecenia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-268">EDMGen allows you to generate a model file, the object layer and the views from the command line.</span></span> <span data-ttu-id="4db1f-269">Jednym z danych wyjściowych będzie plik widoków w wybranym języku, VB lub C @ no__t-0.</span><span class="sxs-lookup"><span data-stu-id="4db1f-269">One of the outputs will be a Views file in your language of choice, VB or C\#.</span></span> <span data-ttu-id="4db1f-270">Jest to plik kodu zawierający Entity SQL fragmenty kodu dla każdego zestawu jednostek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-270">This is a code file containing Entity SQL snippets for each entity set.</span></span> <span data-ttu-id="4db1f-271">Aby włączyć wstępnie wygenerowane widoki, wystarczy dołączyć plik do projektu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-271">To enable pre-generated views, you simply include the file in your project.</span></span>

<span data-ttu-id="4db1f-272">Jeśli ręcznie wprowadzisz zmiany do plików schematu dla modelu, konieczne będzie ponowne wygenerowanie pliku widoków.</span><span class="sxs-lookup"><span data-stu-id="4db1f-272">If you manually make edits to the schema files for the model, you will need to re-generate the views file.</span></span> <span data-ttu-id="4db1f-273">Można to zrobić, uruchamiając EDMGen z flagą **/Mode: ViewGeneration** .</span><span class="sxs-lookup"><span data-stu-id="4db1f-273">You can do this by running EDMGen with the **/mode:ViewGeneration** flag.</span></span>

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a><span data-ttu-id="4db1f-274">2.3.3, jak używać wstępnie wygenerowanych widoków z plikiem EDMX</span><span class="sxs-lookup"><span data-stu-id="4db1f-274">2.3.3 How to use Pre-Generated Views with an EDMX file</span></span>

<span data-ttu-id="4db1f-275">Można również użyć EDMGen do wygenerowania widoków dla pliku EDMX — w poprzednim temacie opisano, jak dodać do tego celu zdarzenie sprzed kompilacji, ale jest to skomplikowane, a w niektórych przypadkach nie jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="4db1f-275">You can also use EDMGen to generate views for an EDMX file - the previously referenced MSDN topic describes how to add a pre-build event to do this - but this is complicated and there are some cases where it isn't possible.</span></span> <span data-ttu-id="4db1f-276">Zwykle łatwiej jest używać szablonu T4 do generowania widoków, gdy model znajduje się w pliku edmx.</span><span class="sxs-lookup"><span data-stu-id="4db1f-276">It's generally easier to use a T4 template to generate the views when your model is in an edmx file.</span></span>

<span data-ttu-id="4db1f-277">Blog zespołu programu ADO.NET ma wpis, który opisuje sposób używania szablon T4 do generowania widoku ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>).</span><span class="sxs-lookup"><span data-stu-id="4db1f-277">The ADO.NET team blog has a post that describes how to use a T4 template for view generation ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>).</span></span> <span data-ttu-id="4db1f-278">Ten wpis obejmuje szablon, który można pobrać i dodać do projektu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-278">This post includes a template that can be downloaded and added to your project.</span></span> <span data-ttu-id="4db1f-279">Szablon został zapisany dla pierwszej wersji Entity Framework, więc nie gwarantujemy pracy z najnowszymi wersjami Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-279">The template was written for the first version of Entity Framework, so they aren’t guaranteed to work with the latest versions of Entity Framework.</span></span> <span data-ttu-id="4db1f-280">Można jednak pobrać bardziej aktualny zestaw szablonów generacji widoku dla Entity Framework 4 i 5from galerię programu Visual Studio:</span><span class="sxs-lookup"><span data-stu-id="4db1f-280">However, you can download a more up-to-date set of view generation templates for Entity Framework 4 and 5from the Visual Studio Gallery:</span></span>

-   <span data-ttu-id="4db1f-281">VB.NET: \< @ NO__T-1</span><span class="sxs-lookup"><span data-stu-id="4db1f-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span></span>
-   <span data-ttu-id="4db1f-282">C @ NO__T-0: \< @ NO__T-2</span><span class="sxs-lookup"><span data-stu-id="4db1f-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span></span>

<span data-ttu-id="4db1f-283">Jeśli używasz platformy Entity Framework 6 można uzyskać widok szablony T4 generacji z galerii Visual Studio na \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-283">If you’re using Entity Framework 6 you can get the view generation T4 templates from the Visual Studio Gallery at \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span></span>

### <a name="24-reducing-the-cost-of-view-generation"></a><span data-ttu-id="4db1f-284">2,4 zmniejszenie kosztów generowania widoku</span><span class="sxs-lookup"><span data-stu-id="4db1f-284">2.4 Reducing the cost of view generation</span></span>

<span data-ttu-id="4db1f-285">Użycie wstępnie wygenerowanych widoków przenosi koszt generowania widoku z ładowania modelu (czasu wykonywania) do czasu projektowania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-285">Using pre-generated views moves the cost of view generation from model loading (run time) to design time.</span></span> <span data-ttu-id="4db1f-286">Chociaż zwiększa to wydajność uruchamiania w czasie wykonywania, nadal będziesz mieć problemy z generowaniem widoku podczas opracowywania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-286">While this improves startup performance at runtime, you will still experience the pain of view generation while you are developing.</span></span> <span data-ttu-id="4db1f-287">Istnieje kilka dodatkowych lew, które mogą pomóc w zmniejszeniu kosztów generowania widoku zarówno w czasie kompilacji, jak i w czasie wykonywania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-287">There are several additional tricks that can help reduce the cost of view generation, both at compile time and run time.</span></span>

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a><span data-ttu-id="4db1f-288">2.4.1 użycie skojarzenia klucza obcego w celu zmniejszenia kosztów generowania widoku</span><span class="sxs-lookup"><span data-stu-id="4db1f-288">2.4.1 Using Foreign Key Associations to reduce view generation cost</span></span>

<span data-ttu-id="4db1f-289">Napotkano wiele przypadków, w których zmiana skojarzeń w modelu z niezależnych skojarzeń z kluczami obcym znacznie poprawiła czas poświęcony na generowanie widoku.</span><span class="sxs-lookup"><span data-stu-id="4db1f-289">We have seen a number of cases where switching the associations in the model from Independent Associations to Foreign Key Associations dramatically improved the time spent in view generation.</span></span>

<span data-ttu-id="4db1f-290">Aby zademonstrować to ulepszenie, Wygenerowano dwie wersje modelu systemu Navision przy użyciu EDMGen.</span><span class="sxs-lookup"><span data-stu-id="4db1f-290">To demonstrate this improvement, we generated two versions of the Navision model by using EDMGen.</span></span> <span data-ttu-id="4db1f-291">*Uwaga: Aby zapoznać się z opisem modelu systemu Navision, zobacz Dodatek C.*</span><span class="sxs-lookup"><span data-stu-id="4db1f-291">*Note: see appendix C for a description of the Navision model.*</span></span> <span data-ttu-id="4db1f-292">Model systemu Navision jest interesujący dla tego ćwiczenia z powodu bardzo dużej liczby jednostek i relacji między nimi.</span><span class="sxs-lookup"><span data-stu-id="4db1f-292">The Navision model is interesting for this exercise due to its very large amount of entities and relationships between them.</span></span>

<span data-ttu-id="4db1f-293">Jedna wersja tego bardzo dużego modelu została wygenerowana przy użyciu skojarzeń kluczy obcych, a druga została wygenerowana z niezależnymi skojarzeniami.</span><span class="sxs-lookup"><span data-stu-id="4db1f-293">One version of this very large model was generated with Foreign Keys Associations and the other was generated with Independent Associations.</span></span> <span data-ttu-id="4db1f-294">Następnie przekroczyć czas trwania generowania widoków dla każdego modelu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-294">We then timed how long it took to generate the views for each model.</span></span> <span data-ttu-id="4db1f-295">Entity Framework 5 test użył metody GenerateViews () z klasy EntityViewGenerator do wygenerowania widoków, podczas gdy test Entity Framework 6 użył metody GenerateViews () z klasy StorageMappingItemCollection.</span><span class="sxs-lookup"><span data-stu-id="4db1f-295">Entity Framework 5 test used the GenerateViews() method from class EntityViewGenerator to generate the views, while the Entity Framework 6 test used the GenerateViews() method from class StorageMappingItemCollection.</span></span> <span data-ttu-id="4db1f-296">Dzieje się tak z powodu restrukturyzacji kodu, która wystąpiła w bazie kodu Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="4db1f-296">This due to code restructuring that occurred in the Entity Framework 6 codebase.</span></span>

<span data-ttu-id="4db1f-297">Przy użyciu Entity Framework 5, generowanie widoku dla modelu z użyciem kluczy obcych trwało 65 minut na maszynie laboratoryjnej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-297">Using Entity Framework 5, view generation for the model with Foreign Keys took 65 minutes in a lab machine.</span></span> <span data-ttu-id="4db1f-298">Jest to nieznane, jak długo zostałyby wykonane w celu wygenerowania widoków dla modelu, który używa niezależnych skojarzeń.</span><span class="sxs-lookup"><span data-stu-id="4db1f-298">It's unknown how long it would have taken to generate the views for the model that used independent associations.</span></span> <span data-ttu-id="4db1f-299">Pozostawiłem test uruchomiony przez ponad miesiąc przed ponownym uruchomieniem maszyny w naszym laboratorium w celu zainstalowania comiesięcznych aktualizacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-299">We left the test running for over a month before the machine was rebooted in our lab to install monthly updates.</span></span>

<span data-ttu-id="4db1f-300">Przy użyciu Entity Framework 6, generowanie widoku dla modelu z kluczami obcymi trwało 28 sekund na tej samej maszynie laboratoryjnej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-300">Using Entity Framework 6, view generation for the model with Foreign Keys took 28 seconds in the same lab machine.</span></span> <span data-ttu-id="4db1f-301">Generowanie widoku dla modelu, który używa niezależnych skojarzeń zajęło 58 sekund.</span><span class="sxs-lookup"><span data-stu-id="4db1f-301">View generation for the model that uses Independent Associations took 58 seconds.</span></span> <span data-ttu-id="4db1f-302">Ulepszenia wykonywane w Entity Framework 6 w swoim kodzie generacji widoku oznaczają, że wiele projektów nie potrzebuje wstępnie wygenerowanych widoków w celu uzyskania krótszych czasu uruchamiania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-302">The improvements done to Entity Framework 6 on its view generation code mean that many projects won’t need pre-generated views to obtain faster startup times.</span></span>

<span data-ttu-id="4db1f-303">Ważne jest, aby zwrócić uwagę, że wstępnie generowane widoki w Entity Framework 4 i 5 można wykonać za pomocą EDMGen lub Entity Framework narzędzia do zarządzania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-303">It’s important to remark that pre-generating views in Entity Framework 4 and 5 can be done with EDMGen or the Entity Framework Power Tools.</span></span> <span data-ttu-id="4db1f-304">Generowanie widoku Entity Framework 6 można przeprowadzić za pomocą narzędzi Entity Framework lub programowo, zgodnie z opisem w [wstępnie wygenerowanych widokach mapowania](~/ef6/fundamentals/performance/pre-generated-views.md).</span><span class="sxs-lookup"><span data-stu-id="4db1f-304">For Entity Framework 6 view generation can be done via the Entity Framework Power Tools or programmatically as described in [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md).</span></span>

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a><span data-ttu-id="4db1f-305">2.4.1.1, jak używać kluczy obcych zamiast niezależnych skojarzeń</span><span class="sxs-lookup"><span data-stu-id="4db1f-305">2.4.1.1 How to use Foreign Keys instead of Independent Associations</span></span>

<span data-ttu-id="4db1f-306">W przypadku korzystania z EDMGen lub Entity Designer w programie Visual Studio, domyślnie otrzymujesz FKs i tylko jedno pole wyboru lub flagę wiersza polecenia, aby przełączać się między FKs i IAs.</span><span class="sxs-lookup"><span data-stu-id="4db1f-306">When using EDMGen or the Entity Designer in Visual Studio, you get FKs by default, and it only takes a single checkbox or command line flag to switch between FKs and IAs.</span></span>

<span data-ttu-id="4db1f-307">Jeśli masz duży model Code First, użycie niezależnych skojarzeń będzie miało ten sam wpływ na generowanie widoku.</span><span class="sxs-lookup"><span data-stu-id="4db1f-307">If you have a large Code First model, using Independent Associations will have the same effect on view generation.</span></span> <span data-ttu-id="4db1f-308">Można uniknąć tego wpływu, dołączając właściwości klucza obcego klas dla obiektów zależnych, chociaż niektórzy deweloperzy rozważą to zanieczyszczenie modelu obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-308">You can avoid this impact by including Foreign Key properties on the classes for your dependent objects, though some developers will consider this to be polluting their object model.</span></span> <span data-ttu-id="4db1f-309">Można znaleźć więcej informacji na ten temat w \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-309">You can find more information on this subject in \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span></span>

| <span data-ttu-id="4db1f-310">W przypadku korzystania z</span><span class="sxs-lookup"><span data-stu-id="4db1f-310">When using</span></span>      | <span data-ttu-id="4db1f-311">Zrób to</span><span class="sxs-lookup"><span data-stu-id="4db1f-311">Do this</span></span>                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="4db1f-312">Entity Designer</span><span class="sxs-lookup"><span data-stu-id="4db1f-312">Entity Designer</span></span> | <span data-ttu-id="4db1f-313">Po dodaniu skojarzenia między dwiema jednostkami upewnij się, że masz ograniczenie referencyjne.</span><span class="sxs-lookup"><span data-stu-id="4db1f-313">After adding an association between two entities, make sure you have a referential constraint.</span></span> <span data-ttu-id="4db1f-314">Więzy referencyjne informują Entity Framework o użyciu kluczy obcych zamiast niezależnych skojarzeń.</span><span class="sxs-lookup"><span data-stu-id="4db1f-314">Referential constraints tell Entity Framework to use Foreign Keys instead of Independent Associations.</span></span> <span data-ttu-id="4db1f-315">Aby uzyskać więcej informacji, odwiedź stronę \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-315">For additional details visit \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>.</span></span> |
| <span data-ttu-id="4db1f-316">EDMGen</span><span class="sxs-lookup"><span data-stu-id="4db1f-316">EDMGen</span></span>          | <span data-ttu-id="4db1f-317">W przypadku generowania plików z bazy danych przy użyciu programu EDMGen klucze obce będą przestrzegane i dodawane do modelu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-317">When using EDMGen to generate your files from the database, your Foreign Keys will be respected and added to the model as such.</span></span> <span data-ttu-id="4db1f-318">Aby uzyskać więcej informacji na temat różnych opcji udostępnianych przez EDMGen odwiedź stronę [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span><span class="sxs-lookup"><span data-stu-id="4db1f-318">For more information on the different options exposed by EDMGen visit [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span></span>                           |
| <span data-ttu-id="4db1f-319">Code First</span><span class="sxs-lookup"><span data-stu-id="4db1f-319">Code First</span></span>      | <span data-ttu-id="4db1f-320">Zapoznaj się z sekcją "Konwencja relacji" tematu [Code First Konwencji](~/ef6/modeling/code-first/conventions/built-in.md) , aby uzyskać informacje na temat dołączania właściwości klucza obcego do obiektów zależnych podczas korzystania z Code First.</span><span class="sxs-lookup"><span data-stu-id="4db1f-320">See the "Relationship Convention" section of the [Code First Conventions](~/ef6/modeling/code-first/conventions/built-in.md) topic for information on how to include foreign key properties on dependent objects when using Code First.</span></span>                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a><span data-ttu-id="4db1f-321">2.4.2 przeniesienie modelu do oddzielnego zestawu</span><span class="sxs-lookup"><span data-stu-id="4db1f-321">2.4.2 Moving your model to a separate assembly</span></span>

<span data-ttu-id="4db1f-322">Gdy model zostanie uwzględniony bezpośrednio w projekcie aplikacji, a widoki są generowane za pomocą zdarzenia przed kompilacją lub szablonu T4, generowanie i walidacja widoku są przeprowadzane zawsze wtedy, gdy projekt zostanie odbudowany, nawet jeśli model nie został zmieniony.</span><span class="sxs-lookup"><span data-stu-id="4db1f-322">When your model is included directly in your application's project and you generate views through a pre-build event or a T4 template, view generation and validation will take place whenever the project is rebuilt, even if the model wasn't changed.</span></span> <span data-ttu-id="4db1f-323">Jeśli przeniesiesz model do oddzielnego zestawu i odwołujesz się do niego z projektu aplikacji, możesz wprowadzić inne zmiany w aplikacji bez konieczności ponownego kompilowania projektu zawierającego model.</span><span class="sxs-lookup"><span data-stu-id="4db1f-323">If you move the model to a separate assembly and reference it from your application's project, you can make other changes to your application without needing to rebuild the project containing the model.</span></span>

<span data-ttu-id="4db1f-324">*Uwaga:*  when przenieść model do oddzielnych zestawów Pamiętaj, aby skopiować parametry połączenia dla modelu do pliku konfiguracji aplikacji projektu klienta.</span><span class="sxs-lookup"><span data-stu-id="4db1f-324">*Note:*  when moving your model to separate assemblies remember to copy the connection strings for the model into the application configuration file of the client project.</span></span>

#### <a name="243-disable-validation-of-an-edmx-based-model"></a><span data-ttu-id="4db1f-325">2.4.3 Wyłącz weryfikację modelu opartego na edmx</span><span class="sxs-lookup"><span data-stu-id="4db1f-325">2.4.3 Disable validation of an edmx-based model</span></span>

<span data-ttu-id="4db1f-326">Modele EDMX są weryfikowane w czasie kompilacji, nawet jeśli model nie został zmieniony.</span><span class="sxs-lookup"><span data-stu-id="4db1f-326">EDMX models are validated at compile time, even if the model is unchanged.</span></span> <span data-ttu-id="4db1f-327">Jeśli Twój model został już zweryfikowany, możesz pominąć walidację w czasie kompilacji, ustawiając właściwość "Weryfikuj przy kompilacji" na wartość false w oknie właściwości.</span><span class="sxs-lookup"><span data-stu-id="4db1f-327">If your model has already been validated, you can suppress validation at compile time by setting the "Validate on Build" property to false in the properties window.</span></span> <span data-ttu-id="4db1f-328">Gdy zmienisz mapowanie lub model, możesz tymczasowo ponownie włączyć weryfikację, aby zweryfikować zmiany.</span><span class="sxs-lookup"><span data-stu-id="4db1f-328">When you change your mapping or model, you can temporarily re-enable validation to verify your changes.</span></span>

<span data-ttu-id="4db1f-329">Należy zauważyć, że wprowadzono ulepszenia wydajności w Entity Framework Designer dla Entity Framework 6, a koszt "Walidacja w kompilacji" jest znacznie mniejszy niż w poprzednich wersjach projektanta.</span><span class="sxs-lookup"><span data-stu-id="4db1f-329">Note that performance improvements were made to the Entity Framework Designer for Entity Framework 6, and the cost of the “Validate on Build” is much lower than in previous versions of the designer.</span></span>

## <a name="3-caching-in-the-entity-framework"></a><span data-ttu-id="4db1f-330">3 buforowanie w Entity Framework</span><span class="sxs-lookup"><span data-stu-id="4db1f-330">3 Caching in the Entity Framework</span></span>

<span data-ttu-id="4db1f-331">Entity Framework ma następujące formy buforowania:</span><span class="sxs-lookup"><span data-stu-id="4db1f-331">Entity Framework has the following forms of caching built-in:</span></span>

1.  <span data-ttu-id="4db1f-332">Buforowanie obiektów — obiekt ObjectStateManager wbudowany w wystąpienie obiektu ObjectContext śledzi w pamięci pamięć obiektów, które zostały pobrane przy użyciu tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-332">Object caching – the ObjectStateManager built into an ObjectContext instance keeps track in memory of the objects that have been retrieved using that instance.</span></span> <span data-ttu-id="4db1f-333">Jest to również nazywane pamięcią podręczną pierwszego poziomu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-333">This is also known as first-level cache.</span></span>
2.  <span data-ttu-id="4db1f-334">Buforowanie planu zapytania — ponowne użycie wygenerowanego magazynu, gdy zapytanie jest wykonywane więcej niż raz.</span><span class="sxs-lookup"><span data-stu-id="4db1f-334">Query Plan Caching - reusing the generated store command when a query is executed more than once.</span></span>
3.  <span data-ttu-id="4db1f-335">Buforowanie metadanych — udostępnia metadane dla modelu w różnych połączeniach z tym samym modelem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-335">Metadata caching - sharing the metadata for a model across different connections to the same model.</span></span>

<span data-ttu-id="4db1f-336">Oprócz pamięci podręcznych, które są dostępne w ramach usługi Box, można również użyć specjalnego rodzaju dostawcy danych ADO.NET, znanego jako dostawca otoki, w celu rozbudowania Entity Framework z pamięcią podręczną dla wyników pobranych z bazy danych, znanej również jako buforowanie drugiego poziomu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-336">Besides the caches that EF provides out of the box, a special kind of ADO.NET data provider known as a wrapping provider can also be used to extend Entity Framework with a cache for the results retrieved from the database, also known as second-level caching.</span></span>

### <a name="31-object-caching"></a><span data-ttu-id="4db1f-337">Buforowanie obiektów 3,1</span><span class="sxs-lookup"><span data-stu-id="4db1f-337">3.1 Object Caching</span></span>

<span data-ttu-id="4db1f-338">Domyślnie, gdy jednostka jest zwracana w wynikach zapytania, tuż przed Dr materializuje, obiekt ObjectContext sprawdzi, czy jednostka z tym samym kluczem została już załadowana do jego obiektu ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="4db1f-338">By default when an entity is returned in the results of a query, just before EF materializes it, the ObjectContext will check if an entity with the same key has already been loaded into its ObjectStateManager.</span></span> <span data-ttu-id="4db1f-339">Jeśli jednostka z tymi samymi kluczami już istnieje, będzie uwzględniać ją w wynikach zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-339">If an entity with the same keys is already present EF will include it in the results of the query.</span></span> <span data-ttu-id="4db1f-340">Mimo że Dr nadal będzie wysyłać zapytanie względem bazy danych, takie zachowanie może ominąć wiele kosztów materializacji jednostki.</span><span class="sxs-lookup"><span data-stu-id="4db1f-340">Although EF will still issue the query against the database, this behavior can bypass much of the cost of materializing the entity multiple times.</span></span>

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a><span data-ttu-id="4db1f-341">3.1.1 pobieranie jednostek z pamięci podręcznej obiektów przy użyciu funkcji DbContext Find</span><span class="sxs-lookup"><span data-stu-id="4db1f-341">3.1.1 Getting entities from the object cache using DbContext Find</span></span>

<span data-ttu-id="4db1f-342">W przeciwieństwie do zwykłego zapytania, Metoda Find w Nieogólnymi (interfejsy API dołączone po raz pierwszy w EF 4,1) przeprowadzi wyszukiwanie w pamięci przed nawet wygenerowaniem zapytania względem bazy danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-342">Unlike a regular query, the Find method in DbSet (APIs included for the first time in EF 4.1) will perform a search in memory before even issuing the query against the database.</span></span> <span data-ttu-id="4db1f-343">Należy pamiętać, że dwa różne wystąpienia obiektu ObjectContext będą miały dwa różne wystąpienia obiektu ObjectStateManager, co oznacza, że mają osobne pamięci podręczne obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-343">It’s important to note that two different ObjectContext instances will have two different ObjectStateManager instances, meaning that they have separate object caches.</span></span>

<span data-ttu-id="4db1f-344">Znajdź używa wartości klucza podstawowego, aby spróbować znaleźć jednostkę śledzoną przez kontekst.</span><span class="sxs-lookup"><span data-stu-id="4db1f-344">Find uses the primary key value to attempt to find an entity tracked by the context.</span></span> <span data-ttu-id="4db1f-345">Jeśli jednostka nie znajduje się w kontekście, zapytanie zostanie wykonane i ocenione względem bazy danych, a wartość null jest zwracana, jeśli jednostka nie zostanie znaleziona w kontekście lub w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-345">If the entity is not in the context then a query will be executed and evaluated against the database, and null is returned if the entity is not found in the context or in the database.</span></span> <span data-ttu-id="4db1f-346">Należy zauważyć, że funkcja Find zwraca również jednostki, które zostały dodane do kontekstu, ale nie zostały jeszcze zapisane w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-346">Note that Find also returns entities that have been added to the context but have not yet been saved to the database.</span></span>

<span data-ttu-id="4db1f-347">W przypadku korzystania z funkcji Znajdź należy wziąć pod uwagę wydajność.</span><span class="sxs-lookup"><span data-stu-id="4db1f-347">There is a performance consideration to be taken when using Find.</span></span> <span data-ttu-id="4db1f-348">Wywołania tej metody domyślnie wyzwalają weryfikację pamięci podręcznej obiektów w celu wykrycia zmian, które nadal oczekują na zatwierdzenie w bazie danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-348">Invocations to this method by default will trigger a validation of the object cache in order to detect changes that are still pending commit to the database.</span></span> <span data-ttu-id="4db1f-349">Ten proces może być bardzo kosztowny, jeśli istnieje bardzo duża liczba obiektów w pamięci podręcznej obiektów lub wykres dużego obiektu dodawany do pamięci podręcznej obiektów, ale można go również wyłączyć.</span><span class="sxs-lookup"><span data-stu-id="4db1f-349">This process can be very expensive if there are a very large number of objects in the object cache or in a large object graph being added to the object cache, but it can also be disabled.</span></span> <span data-ttu-id="4db1f-350">W niektórych przypadkach można postrzegać kolejność o wielkości różnicy w wywołaniu metody Find po wyłączeniu zmian autowykrywania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-350">In certain cases, you may perceive over an order of magnitude of difference in calling the Find method when you disable auto detect changes.</span></span> <span data-ttu-id="4db1f-351">Jeszcze drugi porządek wielkości jest postrzegany, gdy obiekt rzeczywiście znajduje się w pamięci podręcznej, a kiedy obiekt musi zostać pobrany z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-351">Yet a second order of magnitude is perceived when the object actually is in the cache versus when the object has to be retrieved from the database.</span></span> <span data-ttu-id="4db1f-352">Oto przykładowy wykres z miarami wykonywanymi przy użyciu niektórych mikrotestów porównawczych wyrażonych w milisekundach, z obciążeniem jednostek 5000:</span><span class="sxs-lookup"><span data-stu-id="4db1f-352">Here is an example graph with measurements taken using some of our microbenchmarks, expressed in milliseconds, with a load of 5000 entities:</span></span>

<span data-ttu-id="4db1f-353">.NET ![4,5 Skala logarytmiczna](~/ef6/media/net45logscale.png ".NET 4,5 — Skala logarytmiczna")</span><span class="sxs-lookup"><span data-stu-id="4db1f-353">![.NET 4.5 logarithmic scale](~/ef6/media/net45logscale.png ".NET 4.5 - logarithmic scale")</span></span>

<span data-ttu-id="4db1f-354">Przykład wyszukiwania z wyłączonymi zmianami autowykrywania:</span><span class="sxs-lookup"><span data-stu-id="4db1f-354">Example of Find with auto-detect changes disabled:</span></span>

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

<span data-ttu-id="4db1f-355">Co należy wziąć pod uwagę podczas korzystania z metody Find:</span><span class="sxs-lookup"><span data-stu-id="4db1f-355">What you have to consider when using the Find method is:</span></span>

1.  <span data-ttu-id="4db1f-356">Jeśli obiekt nie znajduje się w pamięci podręcznej, korzyści z znalezienia są negacji, ale składnia jest nadal łatwiejsza niż kwerenda według klucza.</span><span class="sxs-lookup"><span data-stu-id="4db1f-356">If the object is not in the cache the benefits of Find are negated, but the syntax is still simpler than a query by key.</span></span>
2.  <span data-ttu-id="4db1f-357">Jeśli funkcja autowykrywania zmian jest włączona, koszt metody Find może wzrosnąć o jeden porządek wielkości lub nawet więcej w zależności od złożoności modelu i liczby jednostek w pamięci podręcznej obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-357">If auto detect changes is enabled the cost of the Find method may increase by one order of magnitude, or even more depending on the complexity of your model and the amount of entities in your object cache.</span></span>

<span data-ttu-id="4db1f-358">Należy również pamiętać, że funkcja Znajdź zwraca tylko jednostkę, której szukasz, i nie ładuje jej automatycznie, jeśli nie znajdują się jeszcze w pamięci podręcznej obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-358">Also, keep in mind that Find only returns the entity you are looking for and it does not automatically loads its associated entities if they are not already in the object cache.</span></span> <span data-ttu-id="4db1f-359">Jeśli musisz pobrać skojarzone jednostki, możesz użyć zapytania przez klucz z ładowaniem eager.</span><span class="sxs-lookup"><span data-stu-id="4db1f-359">If you need to retrieve associated entities, you can use a query by key with eager loading.</span></span> <span data-ttu-id="4db1f-360">Aby uzyskać więcej informacji, zobacz \*\*8,1 opóźnione ładowanie a Eager ładowania @ no__t-0.</span><span class="sxs-lookup"><span data-stu-id="4db1f-360">For more information see **8.1 Lazy Loading vs. Eager Loading**.</span></span>

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a><span data-ttu-id="4db1f-361">3.1.2 problemy z wydajnością, gdy pamięć podręczna obiektów ma wiele jednostek</span><span class="sxs-lookup"><span data-stu-id="4db1f-361">3.1.2 Performance issues when the object cache has many entities</span></span>

<span data-ttu-id="4db1f-362">Pamięć podręczna obiektów ułatwia zwiększenie ogólnej reakcji Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-362">The object cache helps to increase the overall responsiveness of Entity Framework.</span></span> <span data-ttu-id="4db1f-363">Jednak w przypadku, gdy pamięć podręczna obiektów ma załadowane bardzo duże ilości jednostek, może mieć wpływ na niektóre operacje, takie jak dodawanie, usuwanie, Znajdowanie, wprowadzanie, metody SaveChanges i inne.</span><span class="sxs-lookup"><span data-stu-id="4db1f-363">However, when the object cache has a very large amount of entities loaded it may affect certain operations such as Add, Remove, Find, Entry, SaveChanges and more.</span></span> <span data-ttu-id="4db1f-364">W szczególności operacje wyzwalające wywołanie DetectChanges będą mieć negatywny wpływ na bardzo duże pamięci podręczne obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-364">In particular, operations that trigger a call to DetectChanges will be negatively affected by very large object caches.</span></span> <span data-ttu-id="4db1f-365">DetectChanges synchronizuje Graf obiektów z menedżerem stanu obiektów, a jego wydajność zostanie określona bezpośrednio przez rozmiar grafu obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-365">DetectChanges synchronizes the object graph with the object state manager and its performance will determined directly by the size of the object graph.</span></span> <span data-ttu-id="4db1f-366">Aby uzyskać więcej informacji na temat DetectChanges, zobacz [śledzenie zmian w jednostkach poco](https://msdn.microsoft.com/library/dd456848.aspx).</span><span class="sxs-lookup"><span data-stu-id="4db1f-366">For more information about DetectChanges, see [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx).</span></span>

<span data-ttu-id="4db1f-367">W przypadku korzystania z Entity Framework 6 deweloperzy mogą wywołać metodę AddRange i RemoveRange bezpośrednio w Nieogólnymi, a nie iterację w kolekcji i wywołać Dodawanie raz dla każdego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-367">When using Entity Framework 6, developers are able to call AddRange and RemoveRange directly on a DbSet, instead of iterating on a collection and calling Add once per instance.</span></span> <span data-ttu-id="4db1f-368">Zaletą korzystania z metod Range jest to, że koszt usługi DetectChanges jest płatny tylko raz dla całego zestawu jednostek, a nie raz na każdą dodaną jednostkę.</span><span class="sxs-lookup"><span data-stu-id="4db1f-368">The advantage of using the range methods is that the cost of DetectChanges is only paid once for the entire set of entities as opposed to once per each added entity.</span></span>

### <a name="32-query-plan-caching"></a><span data-ttu-id="4db1f-369">Buforowanie planu zapytania 3,2</span><span class="sxs-lookup"><span data-stu-id="4db1f-369">3.2 Query Plan Caching</span></span>

<span data-ttu-id="4db1f-370">Gdy zapytanie jest wykonywane po raz pierwszy, przechodzi przez kompilator wewnętrznego planu, aby przetłumaczyć zapytanie koncepcyjne na polecenie magazynu (na przykład T-SQL, który jest wykonywany w przypadku uruchomienia względem SQL Server).</span><span class="sxs-lookup"><span data-stu-id="4db1f-370">The first time a query is executed, it goes through the internal plan compiler to translate the conceptual query into the store command (for example, the T-SQL which is executed when run against SQL Server).</span></span><span data-ttu-id="4db1f-371">  Jeśli buforowanie planu zapytania jest włączone, przy następnym wykonywaniu zapytania polecenie magazynu jest pobierane bezpośrednio z pamięci podręcznej planu zapytania na potrzeby wykonywania, pomijając kompilator planu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-371">  If query plan caching is enabled, the next time the query is executed the store command is retrieved directly from the query plan cache for execution, bypassing the plan compiler.</span></span>

<span data-ttu-id="4db1f-372">Pamięć podręczna planu zapytania jest współdzielona przez wystąpienia obiektu ObjectContext w ramach tego samego elementu AppDomain.</span><span class="sxs-lookup"><span data-stu-id="4db1f-372">The query plan cache is shared across ObjectContext instances within the same AppDomain.</span></span> <span data-ttu-id="4db1f-373">Nie trzeba przytrzymać wystąpienia obiektu ObjectContext, aby można było korzystać z buforowania planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-373">You don't need to hold onto an ObjectContext instance to benefit from query plan caching.</span></span>

#### <a name="321-some-notes-about-query-plan-caching"></a><span data-ttu-id="4db1f-374">3.2.1 niektóre uwagi dotyczące buforowania planu zapytania</span><span class="sxs-lookup"><span data-stu-id="4db1f-374">3.2.1 Some notes about Query Plan Caching</span></span>

-   <span data-ttu-id="4db1f-375">Pamięć podręczna planu zapytania jest udostępniana dla wszystkich typów zapytań: Entity SQL, LINQ to Entities i obiekty CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="4db1f-375">The query plan cache is shared for all query types: Entity SQL, LINQ to Entities, and CompiledQuery objects.</span></span>
-   <span data-ttu-id="4db1f-376">Domyślnie buforowanie planu zapytania jest włączone dla zapytań Entity SQL, niezależnie od tego, czy są wykonywane za pomocą EntityCommand, czy ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="4db1f-376">By default, query plan caching is enabled for Entity SQL queries, whether executed through an EntityCommand or through an ObjectQuery.</span></span> <span data-ttu-id="4db1f-377">Jest on również domyślnie włączony dla zapytań LINQ to Entities w Entity Framework na platformie .NET 4,5 i w Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="4db1f-377">It is also enabled by default for LINQ to Entities queries in Entity Framework on .NET 4.5, and in Entity Framework 6</span></span>
    -   <span data-ttu-id="4db1f-378">Buforowanie planu zapytania można wyłączyć, ustawiając właściwość EnablePlanCaching (w EntityCommand lub ObjectQuery) na wartość false.</span><span class="sxs-lookup"><span data-stu-id="4db1f-378">Query plan caching can be disabled by setting the EnablePlanCaching property (on EntityCommand or ObjectQuery) to false.</span></span> <span data-ttu-id="4db1f-379">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="4db1f-379">For example:</span></span>
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   <span data-ttu-id="4db1f-380">W przypadku zapytań parametrycznych zmiana wartości parametru będzie nadal trafiać na zbuforowane zapytanie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-380">For parameterized queries, changing the parameter's value will still hit the cached query.</span></span> <span data-ttu-id="4db1f-381">Ale zmiana aspektów parametru (na przykład size, Precision lub Scale) spowoduje, że zostanie osiągnięty inny wpis w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-381">But changing a parameter's facets (for example, size, precision, or scale) will hit a different entry in the cache.</span></span>
-   <span data-ttu-id="4db1f-382">W przypadku korzystania z Entity SQL ciąg zapytania jest częścią klucza.</span><span class="sxs-lookup"><span data-stu-id="4db1f-382">When using Entity SQL, the query string is part of the key.</span></span> <span data-ttu-id="4db1f-383">Zmiana zapytania w ogóle spowoduje powstanie różnych wpisów w pamięci podręcznej, nawet jeśli zapytania są funkcjonalnie równoważne.</span><span class="sxs-lookup"><span data-stu-id="4db1f-383">Changing the query at all will result in different cache entries, even if the queries are functionally equivalent.</span></span> <span data-ttu-id="4db1f-384">Obejmuje to zmiany wielkości liter lub białych znaków.</span><span class="sxs-lookup"><span data-stu-id="4db1f-384">This includes changes to casing or whitespace.</span></span>
-   <span data-ttu-id="4db1f-385">W przypadku korzystania z LINQ zapytanie jest przetwarzane w celu wygenerowania części klucza.</span><span class="sxs-lookup"><span data-stu-id="4db1f-385">When using LINQ, the query is processed to generate a part of the key.</span></span> <span data-ttu-id="4db1f-386">Zmiana wyrażenia LINQ spowoduje wygenerowanie innego klucza.</span><span class="sxs-lookup"><span data-stu-id="4db1f-386">Changing the LINQ expression will therefore generate a different key.</span></span>
-   <span data-ttu-id="4db1f-387">Mogą być stosowane inne ograniczenia techniczne; Zobacz autokompilowane zapytania, aby uzyskać więcej szczegółów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-387">Other technical limitations may apply; see Autocompiled Queries for more details.</span></span>

#### <a name="322-cache-eviction-algorithm"></a><span data-ttu-id="4db1f-388">3.2.2 algorytm wykluczenia pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-388">3.2.2      Cache eviction algorithm</span></span>

<span data-ttu-id="4db1f-389">Zrozumienie, jak działa wewnętrzny algorytm pomoże Ci ustalić, kiedy należy włączyć lub wyłączyć buforowanie planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-389">Understanding how the internal algorithm works will help you figure out when to enable or disable query plan caching.</span></span> <span data-ttu-id="4db1f-390">Algorytm oczyszczania jest następujący:</span><span class="sxs-lookup"><span data-stu-id="4db1f-390">The cleanup algorithm is as follows:</span></span>

1.  <span data-ttu-id="4db1f-391">Gdy pamięć podręczna zawiera określoną liczbę wpisów (800), uruchamiamy czasomierz, który okresowo (raz na minutę) czyść pamięć podręczną.</span><span class="sxs-lookup"><span data-stu-id="4db1f-391">Once the cache contains a set number of entries (800), we start a timer that periodically (once-per-minute) sweeps the cache.</span></span>
2.  <span data-ttu-id="4db1f-392">Podczas czyszczenia pamięci podręcznej wpisy są usuwane z pamięci podręcznej na LFRU (ostatnio używane).</span><span class="sxs-lookup"><span data-stu-id="4db1f-392">During cache sweeps, entries are removed from the cache on a LFRU (Least frequently – recently used) basis.</span></span> <span data-ttu-id="4db1f-393">Ten algorytm pobiera zarówno liczbę trafień, jak i wiek do konta podczas wybierania wpisów, które zostały wysunięte.</span><span class="sxs-lookup"><span data-stu-id="4db1f-393">This algorithm takes both hit count and age into account when deciding which entries are ejected.</span></span>
3.  <span data-ttu-id="4db1f-394">Po zakończeniu każdego odchylenia pamięci podręcznej pamięć podręczna zawiera 800 wpisów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-394">At the end of each cache sweep, the cache again contains 800 entries.</span></span>

<span data-ttu-id="4db1f-395">Wszystkie wpisy pamięci podręcznej są traktowane równomiernie podczas określania wpisów do wykluczenia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-395">All cache entries are treated equally when determining which entries to evict.</span></span> <span data-ttu-id="4db1f-396">Oznacza to, że polecenie magazynu dla CompiledQuery ma tę samą szansę wykluczenia jako polecenie magazynu dla zapytania Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="4db1f-396">This means the store command for a CompiledQuery has the same chance of eviction as the store command for an Entity SQL query.</span></span>

<span data-ttu-id="4db1f-397">Należy zauważyć, że czasomierz wykluczenia pamięci podręcznej jest uruchamiany, gdy w pamięci podręcznej znajdują się 800 jednostek, ale pamięć podręczna jest uruchamiana dopiero po upływie 60 sekund od momentu uruchomienia tego czasomierza.</span><span class="sxs-lookup"><span data-stu-id="4db1f-397">Note that the cache eviction timer is kicked in when there are 800 entities in the cache, but the cache is only swept 60 seconds after this timer is started.</span></span> <span data-ttu-id="4db1f-398">Oznacza to, że przez maksymalnie 60 sekund pamięć podręczna może być coraz większa.</span><span class="sxs-lookup"><span data-stu-id="4db1f-398">That means that for up to 60 seconds your cache may grow to be quite large.</span></span>

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a><span data-ttu-id="4db1f-399">3.2.3 metryki testów ukazujące wydajność buforowania planu zapytania</span><span class="sxs-lookup"><span data-stu-id="4db1f-399">3.2.3       Test Metrics demonstrating query plan caching performance</span></span>

<span data-ttu-id="4db1f-400">Aby zademonstrować efekt buforowania planu zapytania względem wydajności aplikacji, przeprowadzono test, w którym wykonano kilka Entity SQL zapytań względem modelu systemu Navision.</span><span class="sxs-lookup"><span data-stu-id="4db1f-400">To demonstrate the effect of query plan caching on your application's performance, we performed a test where we executed a number of Entity SQL queries against the Navision model.</span></span> <span data-ttu-id="4db1f-401">Zapoznaj się z załącznikiem opis modelu systemu Navision i typy zapytań, które zostały wykonane.</span><span class="sxs-lookup"><span data-stu-id="4db1f-401">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="4db1f-402">W tym teście najpierw wykonujemy iterację na liście zapytań i wykonują każdy raz raz, aby dodać je do pamięci podręcznej (Jeśli buforowanie jest włączone).</span><span class="sxs-lookup"><span data-stu-id="4db1f-402">In this test, we first iterate through the list of queries and execute each one once to add them to the cache (if caching is enabled).</span></span> <span data-ttu-id="4db1f-403">Ten krok jest niepełny.</span><span class="sxs-lookup"><span data-stu-id="4db1f-403">This step is untimed.</span></span> <span data-ttu-id="4db1f-404">Następnie uśpienie głównego wątku przez ponad 60 sekund, aby umożliwić czyszczenie pamięci podręcznej; na koniec wykonujemy iterację na liście po raz drugi, aby wykonać buforowane zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-404">Next, we sleep the main thread for over 60 seconds to allow cache sweeping to take place; finally, we iterate through the list a 2nd time to execute the cached queries.</span></span> <span data-ttu-id="4db1f-405">Ponadto pamięć podręczna planu SQL Server jest opróżniana przed wykonaniem każdego zestawu zapytań, dzięki czemu czasy uzyskiwane dokładnie odzwierciedlają korzyść przydaną przez pamięć podręczną planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-405">Additionally, the SQL Server plan cache is flushed before each set of queries is executed so that the times we obtain accurately reflect the benefit given by the query plan cache.</span></span>

##### <a name="3231-test-results"></a><span data-ttu-id="4db1f-406">3.2.3.1 Wyniki testów</span><span class="sxs-lookup"><span data-stu-id="4db1f-406">3.2.3.1       Test Results</span></span>

| <span data-ttu-id="4db1f-407">Testowanie</span><span class="sxs-lookup"><span data-stu-id="4db1f-407">Test</span></span>                                                                   | <span data-ttu-id="4db1f-408">EF5 Brak pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-408">EF5 no cache</span></span> | <span data-ttu-id="4db1f-409">EF5 w pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-409">EF5 cached</span></span> | <span data-ttu-id="4db1f-410">EF6 Brak pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-410">EF6 no cache</span></span> | <span data-ttu-id="4db1f-411">EF6 w pamięci podręcznej</span><span class="sxs-lookup"><span data-stu-id="4db1f-411">EF6 cached</span></span> |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| <span data-ttu-id="4db1f-412">Wyliczanie wszystkich zapytań 18723</span><span class="sxs-lookup"><span data-stu-id="4db1f-412">Enumerating all 18723 queries</span></span>                                          | <span data-ttu-id="4db1f-413">124</span><span class="sxs-lookup"><span data-stu-id="4db1f-413">124</span></span>          | <span data-ttu-id="4db1f-414">125,4</span><span class="sxs-lookup"><span data-stu-id="4db1f-414">125.4</span></span>      | <span data-ttu-id="4db1f-415">124,3</span><span class="sxs-lookup"><span data-stu-id="4db1f-415">124.3</span></span>        | <span data-ttu-id="4db1f-416">125,3</span><span class="sxs-lookup"><span data-stu-id="4db1f-416">125.3</span></span>      |
| <span data-ttu-id="4db1f-417">Unikanie odchylenia (tylko pierwsze zapytania 800, niezależnie od złożoności)</span><span class="sxs-lookup"><span data-stu-id="4db1f-417">Avoiding sweep (just the first 800 queries, regardless of complexity)</span></span>  | <span data-ttu-id="4db1f-418">41,7</span><span class="sxs-lookup"><span data-stu-id="4db1f-418">41.7</span></span>         | <span data-ttu-id="4db1f-419">5.5</span><span class="sxs-lookup"><span data-stu-id="4db1f-419">5.5</span></span>        | <span data-ttu-id="4db1f-420">40.5</span><span class="sxs-lookup"><span data-stu-id="4db1f-420">40.5</span></span>         | <span data-ttu-id="4db1f-421">5.4</span><span class="sxs-lookup"><span data-stu-id="4db1f-421">5.4</span></span>        |
| <span data-ttu-id="4db1f-422">Tylko zapytania AggregatingSubtotals (łącznie 178), które unikają wycierania</span><span class="sxs-lookup"><span data-stu-id="4db1f-422">Just the AggregatingSubtotals queries (178 total - which avoids sweep)</span></span> | <span data-ttu-id="4db1f-423">39,5</span><span class="sxs-lookup"><span data-stu-id="4db1f-423">39.5</span></span>         | <span data-ttu-id="4db1f-424">4.5</span><span class="sxs-lookup"><span data-stu-id="4db1f-424">4.5</span></span>        | <span data-ttu-id="4db1f-425">38,1</span><span class="sxs-lookup"><span data-stu-id="4db1f-425">38.1</span></span>         | <span data-ttu-id="4db1f-426">4.6</span><span class="sxs-lookup"><span data-stu-id="4db1f-426">4.6</span></span>        |

<span data-ttu-id="4db1f-427">*Wszystkie czasy w sekundach.*</span><span class="sxs-lookup"><span data-stu-id="4db1f-427">*All times in seconds.*</span></span>

<span data-ttu-id="4db1f-428">Dobry — podczas wykonywania wielu odrębnych zapytań (na przykład dynamicznie tworzonych zapytań) buforowanie nie jest pomocne, a wynikiem operacji opróżniania pamięci podręcznej może być zachowanie zapytań, które byłyby korzystne dla najwyższego użycia planu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-428">Moral - when executing lots of distinct queries (for example,  dynamically created queries), caching doesn't help and the resulting flushing of the cache can keep the queries that would benefit the most from plan caching from actually using it.</span></span>

<span data-ttu-id="4db1f-429">Zapytania AggregatingSubtotals są najbardziej skomplikowane dla zapytań, które przetestowały.</span><span class="sxs-lookup"><span data-stu-id="4db1f-429">The AggregatingSubtotals queries are the most complex of the queries we tested with.</span></span> <span data-ttu-id="4db1f-430">Zgodnie z oczekiwaniami, bardziej skomplikowane jest zapytanie, tym więcej korzyści będzie można znaleźć w temacie buforowanie planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-430">As expected, the more complex the query is, the more benefit you will see from query plan caching.</span></span>

<span data-ttu-id="4db1f-431">Ponieważ CompiledQuery jest naprawdę zapytania LINQ z buforowanym planem, porównanie CompiledQuery i równoważnej kwerendy Entity SQL powinna mieć podobne wyniki.</span><span class="sxs-lookup"><span data-stu-id="4db1f-431">Because a CompiledQuery is really a LINQ query with its plan cached, the comparison of a CompiledQuery versus the equivalent Entity SQL query should have similar results.</span></span> <span data-ttu-id="4db1f-432">W rzeczywistości, jeśli aplikacja ma wiele zapytań Entity SQL dynamicznych, wypełnianie pamięci podręcznej przy użyciu zapytań spowoduje również skuteczną CompiledQueries "dekompilowanie" po opróżnieniu z pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-432">In fact, if an app has lots of dynamic Entity SQL queries, filling the cache with queries will also effectively cause CompiledQueries to “decompile” when they are flushed from the cache.</span></span> <span data-ttu-id="4db1f-433">W tym scenariuszu wydajność można ulepszyć, wyłączając buforowanie w zapytaniach dynamicznych w celu określenia priorytetów CompiledQueries.</span><span class="sxs-lookup"><span data-stu-id="4db1f-433">In this scenario, performance may be improved by disabling caching on the dynamic queries to prioritize the CompiledQueries.</span></span> <span data-ttu-id="4db1f-434">Jeszcze lepszym rozwiązaniem jest ponowne napisanie aplikacji w celu używania zapytań parametrycznych zamiast zapytań dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-434">Better yet, of course, would be to rewrite the app to use parameterized queries instead of dynamic queries.</span></span>

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a><span data-ttu-id="4db1f-435">3,3 przy użyciu CompiledQuery, aby zwiększyć wydajność przy użyciu zapytań LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-435">3.3 Using CompiledQuery to improve performance with LINQ queries</span></span>

<span data-ttu-id="4db1f-436">Nasze testy wskazują, że korzystanie z usługi CompiledQuery może przynieść do 7% przez skompilowane przez siebie zapytania LINQ. oznacza to, że poświęcimy 7% mniej czasu na wykonanie kodu ze stosu Entity Frameworkowego; nie oznacza to, że aplikacja będzie o 7% szybsza.</span><span class="sxs-lookup"><span data-stu-id="4db1f-436">Our tests indicate that using CompiledQuery can bring a benefit of 7% over autocompiled LINQ queries; this means that you’ll spend 7% less time executing code from the Entity Framework stack; it does not mean your application will be 7% faster.</span></span> <span data-ttu-id="4db1f-437">Ogólnie mówiąc, koszt pisania i konserwacji obiektów CompiledQuery w EF 5,0 może nie być cenny w porównaniu z korzyściami.</span><span class="sxs-lookup"><span data-stu-id="4db1f-437">Generally speaking, the cost of writing and maintaining CompiledQuery objects in EF 5.0 may not be worth the trouble when compared to the benefits.</span></span> <span data-ttu-id="4db1f-438">Przebieg może się różnić, dlatego należy skorzystać z tej opcji, jeśli projekt wymaga dodatkowej wypychania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-438">Your mileage may vary, so exercise this option if your project requires the extra push.</span></span> <span data-ttu-id="4db1f-439">Należy zauważyć, że CompiledQueries są zgodne tylko z modelami pochodnymi ObjectContext i nie są zgodne z modelami pochodnymi DbContext.</span><span class="sxs-lookup"><span data-stu-id="4db1f-439">Note that CompiledQueries are only compatible with ObjectContext-derived models, and not compatible with DbContext-derived models.</span></span>

<span data-ttu-id="4db1f-440">Aby uzyskać więcej informacji na temat tworzenia i wywoływania CompiledQuery, zobacz [skompilowane zapytania (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span><span class="sxs-lookup"><span data-stu-id="4db1f-440">For more information on creating and invoking a CompiledQuery, see [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span></span>

<span data-ttu-id="4db1f-441">W przypadku korzystania z CompiledQuery należy wziąć pod uwagę dwa kwestie, a mianowicie wymagania dotyczące korzystania z wystąpień statycznych i problemów z możliwością redagowania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-441">There are two considerations you have to take when using a CompiledQuery, namely the requirement to use static instances and the problems they have with composability.</span></span> <span data-ttu-id="4db1f-442">Poniżej znajduje się szczegółowy opis tych dwóch zagadnień.</span><span class="sxs-lookup"><span data-stu-id="4db1f-442">Here follows an in-depth explanation of these two considerations.</span></span>

#### <a name="331-use-static-compiledquery-instances"></a><span data-ttu-id="4db1f-443">3.3.1 użycie statycznych wystąpień CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="4db1f-443">3.3.1       Use static CompiledQuery instances</span></span>

<span data-ttu-id="4db1f-444">Ponieważ Kompilowanie zapytania LINQ jest czasochłonnym procesem, nie chcemy go wykonywać za każdym razem, gdy będziemy musieli pobrać dane z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-444">Since compiling a LINQ query is a time-consuming process, we don’t want to do it every time we need to fetch data from the database.</span></span> <span data-ttu-id="4db1f-445">Wystąpienia CompiledQuery umożliwiają kompilowanie i uruchamianie wielu razy, ale należy zachować ostrożność i zadawać, aby ponownie używać tego samego wystąpienia CompiledQuery za każdym razem, zamiast kompilować go w trybie failover i ponownie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-445">CompiledQuery instances allow you to compile once and run multiple times, but you have to be careful and procure to re-use the same CompiledQuery instance every time instead of compiling it over and over again.</span></span> <span data-ttu-id="4db1f-446">Użycie statycznych elementów członkowskich do przechowywania wystąpień CompiledQuery będzie konieczne; w przeciwnym razie nie zobaczysz żadnej korzyści.</span><span class="sxs-lookup"><span data-stu-id="4db1f-446">The use of static members to store the CompiledQuery instances becomes necessary; otherwise you won’t see any benefit.</span></span>

<span data-ttu-id="4db1f-447">Załóżmy na przykład, że strona ma następującą treść metody, aby obsłużyć wyświetlanie produktów dla wybranej kategorii:</span><span class="sxs-lookup"><span data-stu-id="4db1f-447">For example, suppose your page has the following method body to handle displaying the products for the selected category:</span></span>

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

<span data-ttu-id="4db1f-448">W takim przypadku na bieżąco utworzysz nowe wystąpienie CompiledQuery przy każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="4db1f-448">In this case, you will create a new CompiledQuery instance on the fly every time the method is called.</span></span> <span data-ttu-id="4db1f-449">Zamiast wyświetlać zalety wydajności przez pobranie polecenia Zapisz z pamięci podręcznej planu zapytania, CompiledQuery przejdzie przez kompilator planu za każdym razem, gdy tworzone jest nowe wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-449">Instead of seeing performance benefits by retrieving the store command from the query plan cache, the CompiledQuery will go through the plan compiler every time a new instance is created.</span></span> <span data-ttu-id="4db1f-450">W rzeczywistości będzie to zanieczyszczenie pamięci podręcznej planu zapytania przy użyciu nowego wpisu CompiledQuery przy każdym wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="4db1f-450">In fact, you will be polluting your query plan cache with a new CompiledQuery entry every time the method is called.</span></span>

<span data-ttu-id="4db1f-451">Zamiast tego należy utworzyć wystąpienie statyczne skompilowanego zapytania, aby można było wywołać to samo skompilowane zapytanie za każdym razem, gdy wywoływana jest metoda.</span><span class="sxs-lookup"><span data-stu-id="4db1f-451">Instead, you want to create a static instance of the compiled query, so you are invoking the same compiled query every time the method is called.</span></span> <span data-ttu-id="4db1f-452">Jednym ze sposobów jest dodanie wystąpienia CompiledQuery jako elementu członkowskiego kontekstu obiektu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-452">One way to so this is by adding the CompiledQuery instance as a member of your object context.</span></span><span data-ttu-id="4db1f-453">  Następnie można zwiększyć czytelność, uzyskując dostęp do CompiledQuery za pomocą metody pomocnika:</span><span class="sxs-lookup"><span data-stu-id="4db1f-453">  You can then make things a little cleaner by accessing the CompiledQuery through a helper method:</span></span>

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

<span data-ttu-id="4db1f-454">Ta metoda pomocnika zostałaby wywołana w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="4db1f-454">This helper method would be invoked as follows:</span></span>

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a><span data-ttu-id="4db1f-455">3.3.2 redagowanie w CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="4db1f-455">3.3.2       Composing over a CompiledQuery</span></span>

<span data-ttu-id="4db1f-456">Możliwość tworzenia wszystkich zapytań LINQ jest niezwykle przydatna. w tym celu po prostu wywołaj metodę po interfejsie IQueryable, takim jak *Skip ()* lub *Count ()* .</span><span class="sxs-lookup"><span data-stu-id="4db1f-456">The ability to compose over any LINQ query is extremely useful; to do this, you simply invoke a method after the IQueryable such as *Skip()* or *Count()*.</span></span> <span data-ttu-id="4db1f-457">Jednak zasadniczo zwraca nowy obiekt IQueryable.</span><span class="sxs-lookup"><span data-stu-id="4db1f-457">However, doing so essentially returns a new IQueryable object.</span></span> <span data-ttu-id="4db1f-458">Nie ma nic, aby nie było możliwe, aby nie zatrzymywać od firmy CompiledQuery, że spowoduje to wygenerowanie nowego obiektu IQueryable, który wymaga ponownego przekazania kompilatora planu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-458">While there’s nothing to stop you technically from composing over a CompiledQuery, doing so will cause the generation of a new IQueryable object that requires passing through the plan compiler again.</span></span>

<span data-ttu-id="4db1f-459">Niektóre składniki będą używały złożonych obiektów IQueryable do włączenia zaawansowanych funkcji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-459">Some components will make use of composed IQueryable objects to enable advanced functionality.</span></span> <span data-ttu-id="4db1f-460">Na przykład ASP. Widok GridView sieci może być powiązany z danymi z obiektem IQueryable za pośrednictwem właściwości SelectMethod.</span><span class="sxs-lookup"><span data-stu-id="4db1f-460">For example, ASP.NET’s GridView can be data-bound to an IQueryable object via the SelectMethod property.</span></span> <span data-ttu-id="4db1f-461">W widoku GridView utworzysz ten obiekt IQueryable, aby umożliwić sortowanie i stronicowanie w modelu danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-461">The GridView will then compose over this IQueryable object to allow sorting and paging over the data model.</span></span> <span data-ttu-id="4db1f-462">Jak widać, użycie CompiledQuery dla widoku GridView nie spowoduje pojawienia się skompilowanego zapytania, ale spowoduje wygenerowanie nowej autokompilowanego zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-462">As you can see, using a CompiledQuery for the GridView would not hit the compiled query but would generate a new autocompiled query.</span></span>

<span data-ttu-id="4db1f-463">Jedno miejsce, w którym można w tym celu wykonać w przypadku dodawania filtrów progresywnych do zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-463">One place where you may run into this is when adding progressive filters to a query.</span></span> <span data-ttu-id="4db1f-464">Załóżmy na przykład, że masz stronę klienci z kilkoma listami rozwijanymi dla filtrów opcjonalnych (na przykład Country i OrdersCount).</span><span class="sxs-lookup"><span data-stu-id="4db1f-464">For example, suppose you had a Customers page with several drop-down lists for optional filters (for example, Country and OrdersCount).</span></span> <span data-ttu-id="4db1f-465">Te filtry można redagować na podstawie wyników CompiledQuery, ale to spowoduje, że nowe zapytanie przejdzie przez kompilator planu przy każdym jego wykonaniu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-465">You can compose these filters over the IQueryable results of a CompiledQuery, but doing so will result in the new query going through the plan compiler every time you execute it.</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="4db1f-466">Aby uniknąć tej ponownej kompilacji, możesz ponownie napisać CompiledQuery, aby uwzględnić możliwe filtry:</span><span class="sxs-lookup"><span data-stu-id="4db1f-466">To avoid this re-compilation, you can rewrite the CompiledQuery to take the possible filters into account:</span></span>

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

<span data-ttu-id="4db1f-467">Które zostałyby wywołane w interfejsie użytkownika, np.:</span><span class="sxs-lookup"><span data-stu-id="4db1f-467">Which would be invoked in the UI like:</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="4db1f-468">W tym miejscu jest to polecenie wygenerowany magazyn, które będzie miało zawsze filtry z sprawdzeniami null, ale te wartości powinny być dość proste, aby serwer bazy danych mógł zoptymalizować:</span><span class="sxs-lookup"><span data-stu-id="4db1f-468">A tradeoff here is the generated store command will always have the filters with the null checks, but these should be fairly simple for the database server to optimize:</span></span>

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a><span data-ttu-id="4db1f-469">buforowanie metadanych 3,4</span><span class="sxs-lookup"><span data-stu-id="4db1f-469">3.4 Metadata caching</span></span>

<span data-ttu-id="4db1f-470">Entity Framework obsługuje również buforowanie metadanych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-470">The Entity Framework also supports Metadata caching.</span></span> <span data-ttu-id="4db1f-471">Jest to zasadniczo buforowanie informacji o typie i informacje mapowania typu "na typ do bazy danych" między różnymi połączeniami z tym samym modelem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-471">This is essentially caching of type information and type-to-database mapping information across different connections to the same model.</span></span> <span data-ttu-id="4db1f-472">Pamięć podręczna metadanych jest unikatowa dla domeny aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-472">The Metadata cache is unique per AppDomain.</span></span>

#### <a name="341-metadata-caching-algorithm"></a><span data-ttu-id="4db1f-473">w algorytmie buforowania metadanych</span><span class="sxs-lookup"><span data-stu-id="4db1f-473">3.4.1 Metadata Caching algorithm</span></span>

1.  <span data-ttu-id="4db1f-474">Informacje o metadanych dla modelu są przechowywane w obiekt ItemCollection dla każdego EntityConnectionu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-474">Metadata information for a model is stored in an ItemCollection for each EntityConnection.</span></span>
    -   <span data-ttu-id="4db1f-475">Jako notatka boczna istnieją różne obiekty obiekt ItemCollection dla różnych części modelu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-475">As a side note, there are different ItemCollection objects for different parts of the model.</span></span> <span data-ttu-id="4db1f-476">Na przykład StoreItemCollections zawiera informacje o modelu bazy danych; ObjectItemCollection zawiera informacje o modelu danych; EdmItemCollection zawiera informacje o modelu koncepcyjnym.</span><span class="sxs-lookup"><span data-stu-id="4db1f-476">For example, StoreItemCollections contains the information about the database model; ObjectItemCollection contains information about the data model; EdmItemCollection contains information about the conceptual model.</span></span>

2.  <span data-ttu-id="4db1f-477">Jeśli dwa połączenia używają tych samych parametrów połączenia, będą współużytkować to samo wystąpienie obiekt ItemCollection.</span><span class="sxs-lookup"><span data-stu-id="4db1f-477">If two connections use the same connection string, they will share the same ItemCollection instance.</span></span>
3.  <span data-ttu-id="4db1f-478">Funkcja równoważna funkcjonalnie, ale różne ciągi połączenia mogą powodować różne metadane.</span><span class="sxs-lookup"><span data-stu-id="4db1f-478">Functionally equivalent but textually different connection strings may result in different metadata caches.</span></span> <span data-ttu-id="4db1f-479">Tokenize ciągi połączeń, więc po prostu zmiana kolejności tokenów powinna spowodować, że metadane udostępnione.</span><span class="sxs-lookup"><span data-stu-id="4db1f-479">We do tokenize connection strings, so simply changing the order of the tokens should result in shared metadata.</span></span> <span data-ttu-id="4db1f-480">Ale dwa parametry połączenia, które wydaje się funkcjonalnie takie same, mogą nie być oceniane jako identyczne po tokenizacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-480">But two connection strings that seem functionally the same may not be evaluated as identical after tokenization.</span></span>
4.  <span data-ttu-id="4db1f-481">Obiekt ItemCollection jest okresowo sprawdzana pod kątem użycia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-481">The ItemCollection is periodically checked for use.</span></span> <span data-ttu-id="4db1f-482">Jeśli okaże się, że nie uzyskano ostatnio dostępu do obszaru roboczego, zostanie on oznaczony do oczyszczenia przy następnym wyczyszczeniu pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-482">If it is determined that a workspace has not been accessed recently, it will be marked for cleanup on the next cache sweep.</span></span>
5.  <span data-ttu-id="4db1f-483">Tylko utworzenie EntityConnection spowoduje utworzenie pamięci podręcznej metadanych (mimo że kolekcje elementów w niej nie zostaną zainicjowane do momentu otwarcia połączenia).</span><span class="sxs-lookup"><span data-stu-id="4db1f-483">Merely creating an EntityConnection will cause a metadata cache to be created (though the item collections in it will not be initialized until the connection is opened).</span></span> <span data-ttu-id="4db1f-484">Ten obszar roboczy pozostanie w pamięci do momentu, aż algorytm buforowania ustali, że nie jest używany.</span><span class="sxs-lookup"><span data-stu-id="4db1f-484">This workspace will remain in-memory until the caching algorithm determines it is not “in use”.</span></span>

<span data-ttu-id="4db1f-485">Zespół Doradczy klientów zapisane wpis w blogu, który opisuje zawierający odwołanie do obiektu ItemCollection w celu uniknięcia "wycofywania", korzystając z dużych modeli: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-485">The Customer Advisory Team has written a blog post that describes holding a reference to an ItemCollection in order to avoid "deprecation" when using large models: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.</span></span>

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a><span data-ttu-id="4db1f-486">3.4.2 relację między buforowaniem metadanych a buforowaniem planu zapytania</span><span class="sxs-lookup"><span data-stu-id="4db1f-486">3.4.2 The relationship between Metadata Caching and Query Plan Caching</span></span>

<span data-ttu-id="4db1f-487">Wystąpienie pamięci podręcznej planu zapytania jest przechowywane w obiekt ItemCollection obiektu MetadataWorkspace.</span><span class="sxs-lookup"><span data-stu-id="4db1f-487">The query plan cache instance lives in the MetadataWorkspace's ItemCollection of store types.</span></span> <span data-ttu-id="4db1f-488">Oznacza to, że polecenia magazynu w pamięci podręcznej będą używane do wykonywania zapytań dotyczących kontekstu wystąpienia przy użyciu danego obiektu MetadataWorkspace.</span><span class="sxs-lookup"><span data-stu-id="4db1f-488">This means that cached store commands will be used for queries against any context instantiated using a given MetadataWorkspace.</span></span> <span data-ttu-id="4db1f-489">Oznacza to również, że jeśli istnieją dwa parametry połączeń, które są nieco inne i nie pasują po tokenizowanie, będą dostępne różne wystąpienia pamięci podręcznej planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-489">It also means that if you have two connections strings that are slightly different and don't match after tokenizing, you will have different query plan cache instances.</span></span>

### <a name="35-results-caching"></a><span data-ttu-id="4db1f-490">Buforowanie wyników 3,5</span><span class="sxs-lookup"><span data-stu-id="4db1f-490">3.5 Results caching</span></span>

<span data-ttu-id="4db1f-491">Dzięki buforowaniu wyników (nazywanej także "buforowaniem drugiego poziomu") można zachować wyniki zapytań w lokalnej pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-491">With results caching (also known as "second-level caching"), you keep the results of queries in a local cache.</span></span> <span data-ttu-id="4db1f-492">Podczas wykonywania zapytania należy najpierw sprawdzić, czy wyniki są dostępne lokalnie przed wykonaniem zapytania względem magazynu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-492">When issuing a query, you first see if the results are available locally before you query against the store.</span></span> <span data-ttu-id="4db1f-493">Podczas gdy buforowanie wyników nie jest bezpośrednio obsługiwane przez Entity Framework, można dodać pamięć podręczną drugiego poziomu przy użyciu dostawcy otoki.</span><span class="sxs-lookup"><span data-stu-id="4db1f-493">While results caching isn't directly supported by Entity Framework, it's possible to add a second level cache by using a wrapping provider.</span></span> <span data-ttu-id="4db1f-494">Przykładem dostawcy zawijania z pamięci podręcznej drugiego poziomu jest [Entity Framework Alachisofta pamięć podręczna drugiego poziomu oparta na NCache](https://www.alachisoft.com/ncache/entity-framework.html).</span><span class="sxs-lookup"><span data-stu-id="4db1f-494">An example wrapping provider with a second-level cache is Alachisoft's [Entity Framework Second Level Cache based on NCache](https://www.alachisoft.com/ncache/entity-framework.html).</span></span>

<span data-ttu-id="4db1f-495">Ta implementacja buforowania drugiego poziomu jest funkcją wstrzykiwaną, która ma miejsce po obliczeniu wyrażenia LINQ (i funcletized), a plan wykonywania zapytania jest obliczany lub pobierany z pamięci podręcznej pierwszego poziomu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-495">This implementation of second-level caching is an injected functionality that takes place after the LINQ expression has been evaluated (and funcletized) and the query execution plan is computed or retrieved from the first-level cache.</span></span> <span data-ttu-id="4db1f-496">Pamięć podręczna drugiego poziomu będzie następnie przechowywać tylko wyniki nieprzetworzonej bazy danych, więc potok materializację nadal zostanie wykonany.</span><span class="sxs-lookup"><span data-stu-id="4db1f-496">The second-level cache will then store only the raw database results, so the materialization pipeline still executes afterwards.</span></span>

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a><span data-ttu-id="4db1f-497">3.5.1 dodatkowe informacje dotyczące buforowania wyników w ramach dostawcy zawijania</span><span class="sxs-lookup"><span data-stu-id="4db1f-497">3.5.1 Additional references for results caching with the wrapping provider</span></span>

-   <span data-ttu-id="4db1f-498">Julie Lerman zapisał "pamięć podręczną drugiego poziomu w Entity Framework i Windows Azure" w witrynie MSDN, która obejmuje jak zaktualizować przykładowego dostawcę otoki do korzystania z pamięci podręcznej systemu Windows Server AppFabric: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span><span class="sxs-lookup"><span data-stu-id="4db1f-498">Julie Lerman has written a "Second-Level Caching in Entity Framework and Windows Azure" MSDN article that includes how to update the sample wrapping provider to use Windows Server AppFabric caching: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span></span>
-   <span data-ttu-id="4db1f-499">Jeśli pracujesz z Entity Framework 5, blog zespołu ma wpis, w której opisano Rozpoczynanie pracy z pamięci podręcznej dostawcy programu Entity Framework 5: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-499">If you are working with Entity Framework 5, the team blog has a post that describes how to get things running with the caching provider for Entity Framework 5: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>.</span></span> <span data-ttu-id="4db1f-500">Zawiera również szablon T4, który pomaga zautomatyzować Dodawanie buforowania drugiego poziomu do projektu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-500">It also includes a T4 template to help automate adding the 2nd-level caching to your project.</span></span>

## <a name="4-autocompiled-queries"></a><span data-ttu-id="4db1f-501">4 autokompilowane zapytania</span><span class="sxs-lookup"><span data-stu-id="4db1f-501">4 Autocompiled Queries</span></span>

<span data-ttu-id="4db1f-502">Gdy zapytanie jest wydawane dla bazy danych przy użyciu Entity Framework, musi przejść przez serię kroków, zanim rzeczywiście materializacji wyniki; jednym z tych kroków jest kompilacja zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-502">When a query is issued against a database using Entity Framework, it must go through a series of steps before actually materializing the results; one such step is Query Compilation.</span></span> <span data-ttu-id="4db1f-503">Wiadomo, że Entity SQL zapytania mają dobrą wydajność, ponieważ są one automatycznie buforowane, więc drugi lub trzeci czas wykonywania tego samego zapytania może pominąć kompilator planu i zamiast tego użyć buforowanego planu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-503">Entity SQL queries were known to have good performance as they are automatically cached, so the second or third time you execute the same query it can skip the plan compiler and use the cached plan instead.</span></span>

<span data-ttu-id="4db1f-504">Entity Framework 5 wprowadzono również automatyczne buforowanie dla zapytań LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="4db1f-504">Entity Framework 5 introduced automatic caching for LINQ to Entities queries as well.</span></span> <span data-ttu-id="4db1f-505">W poprzednich wersjach Entity Framework tworzenia CompiledQuery w celu przyspieszenia działania była powszechną gwarancją, ponieważ spowodowałoby to przeprowadzenie LINQ to Entities zapytania w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-505">In past editions of Entity Framework creating a CompiledQuery to speed your performance was a common practice, as this would make your LINQ to Entities query cacheable.</span></span> <span data-ttu-id="4db1f-506">Ponieważ buforowanie jest teraz wykonywane automatycznie bez użycia CompiledQuery, wywoływana jest funkcja "autokompilowane zapytania".</span><span class="sxs-lookup"><span data-stu-id="4db1f-506">Since caching is now done automatically without the use of a CompiledQuery, we call this feature “autocompiled queries”.</span></span> <span data-ttu-id="4db1f-507">Aby uzyskać więcej informacji na temat pamięci podręcznej planu zapytania i jej Mechanics, zobacz buforowanie planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-507">For more information about the query plan cache and its mechanics, see Query Plan Caching.</span></span>

<span data-ttu-id="4db1f-508">Entity Framework wykrywa, kiedy zapytanie wymaga ponownej kompilacji, i robi to, gdy zapytanie jest wywoływane, nawet jeśli zostało skompilowane wcześniej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-508">Entity Framework detects when a query requires to be recompiled, and does so when the query is invoked even if it had been compiled before.</span></span> <span data-ttu-id="4db1f-509">Typowe warunki, które powodują ponowną kompilację zapytania, to:</span><span class="sxs-lookup"><span data-stu-id="4db1f-509">Common conditions that cause the query to be recompiled are:</span></span>

-   <span data-ttu-id="4db1f-510">Zmiana MergeOption skojarzonego z zapytaniem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-510">Changing the MergeOption associated to your query.</span></span> <span data-ttu-id="4db1f-511">Zapytanie buforowane nie zostanie użyte, a następnie kompilator planu zostanie uruchomiony ponownie, a nowo utworzony plan zostanie zapisany w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-511">The cached query will not be used, instead the plan compiler will run again and the newly created plan gets cached.</span></span>
-   <span data-ttu-id="4db1f-512">Zmiana wartości ContextOptions. UseCSharpNullComparisonBehavior.</span><span class="sxs-lookup"><span data-stu-id="4db1f-512">Changing the value of ContextOptions.UseCSharpNullComparisonBehavior.</span></span> <span data-ttu-id="4db1f-513">Ten sam efekt jest taki sam jak zmiana MergeOption.</span><span class="sxs-lookup"><span data-stu-id="4db1f-513">You get the same effect as changing the MergeOption.</span></span>

<span data-ttu-id="4db1f-514">Inne warunki mogą uniemożliwić korzystanie z pamięci podręcznej przez zapytanie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-514">Other conditions can prevent your query from using the cache.</span></span> <span data-ttu-id="4db1f-515">Typowe przykłady to:</span><span class="sxs-lookup"><span data-stu-id="4db1f-515">Common examples are:</span></span>

-   <span data-ttu-id="4db1f-516">Za pomocą interfejsu IEnumerable @ no__t-0T @ no__t-1. Zawiera @ no__t-2 @ no__t-3 (T wartość).</span><span class="sxs-lookup"><span data-stu-id="4db1f-516">Using IEnumerable&lt;T&gt;.Contains&lt;&gt;(T value).</span></span>
-   <span data-ttu-id="4db1f-517">Korzystanie z funkcji, które generują zapytania ze stałymi.</span><span class="sxs-lookup"><span data-stu-id="4db1f-517">Using functions that produce queries with constants.</span></span>
-   <span data-ttu-id="4db1f-518">Używanie właściwości niemapowanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-518">Using the properties of a non-mapped object.</span></span>
-   <span data-ttu-id="4db1f-519">Łączenie zapytania z innym zapytaniem, które wymaga ponownej kompilacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-519">Linking your query to another query that requires to be recompiled.</span></span>

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a><span data-ttu-id="4db1f-520">4,1 przy użyciu interfejsu IEnumerable @ no__t-0T @ no__t-1. Zawiera wartość @ no__t-2T @ no__t-3 (T wartość)</span><span class="sxs-lookup"><span data-stu-id="4db1f-520">4.1 Using IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value)</span></span>

<span data-ttu-id="4db1f-521">Entity Framework nie buforuje zapytań, które wywołują interfejs IEnumerable @ no__t-0T @ no__t-1. Zawiera element @ no__t-2T @ no__t-3 (T Value) względem kolekcji w pamięci, ponieważ wartości kolekcji są uznawane za nietrwałe.</span><span class="sxs-lookup"><span data-stu-id="4db1f-521">Entity Framework does not cache queries that invoke IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) against an in-memory collection, since the values of the collection are considered volatile.</span></span> <span data-ttu-id="4db1f-522">Następujące przykładowe zapytanie nie zostanie zapisane w pamięci podręcznej, więc będzie zawsze przetwarzane przez kompilator planu:</span><span class="sxs-lookup"><span data-stu-id="4db1f-522">The following example query will not be cached, so it will always be processed by the plan compiler:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="4db1f-523">Należy zauważyć, że rozmiar interfejsu IEnumerable, z którym jest wykonywane, określa, jak szybko lub jak wolno kompilować zapytanie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-523">Note that the size of the IEnumerable against which Contains is executed determines how fast or how slow your query is compiled.</span></span> <span data-ttu-id="4db1f-524">Wydajność może znacznie pogorszyć się podczas korzystania z dużych kolekcji, takich jak pokazane w powyższym przykładzie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-524">Performance can suffer significantly when using large collections such as the one shown in the example above.</span></span>

<span data-ttu-id="4db1f-525">Entity Framework 6 zawiera optymalizacje w sposób, w jaki interfejs IEnumerable @ no__t-0T @ no__t-1. Zawiera @ no__t-2T @ no__t-3 (T wartość) działa podczas wykonywania zapytań.</span><span class="sxs-lookup"><span data-stu-id="4db1f-525">Entity Framework 6 contains optimizations to the way IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) works when queries are executed.</span></span> <span data-ttu-id="4db1f-526">Wygenerowany kod SQL jest znacznie szybszy do tworzenia i bardziej czytelny, a w większości przypadków jest również wykonywany szybciej na serwerze.</span><span class="sxs-lookup"><span data-stu-id="4db1f-526">The SQL code that is generated is much faster to produce and more readable, and in most cases it also executes faster in the server.</span></span>

### <a name="42-using-functions-that-produce-queries-with-constants"></a><span data-ttu-id="4db1f-527">4,2 użycie funkcji generujących zapytania ze stałymi</span><span class="sxs-lookup"><span data-stu-id="4db1f-527">4.2 Using functions that produce queries with constants</span></span>

<span data-ttu-id="4db1f-528">Operatory Skip (), Take (), Contains () i DefautIfEmpty () LINQ nie generują zapytań SQL z parametrami, ale zamiast tego przechodzą wartości do nich jako stałe.</span><span class="sxs-lookup"><span data-stu-id="4db1f-528">The Skip(), Take(), Contains() and DefautIfEmpty() LINQ operators do not produce SQL queries with parameters but instead put the values passed to them as constants.</span></span> <span data-ttu-id="4db1f-529">Z tego powodu zapytania, które mogłyby w przeciwnym razie być takie same, kończą się zanieczyszczeniem pamięci podręcznej planu zapytania, zarówno na stosie EF, jak i na serwerze bazy danych, i nie są ponownie wykorzystywane, chyba że te same stałe są używane w kolejnym wykonaniu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-529">Because of this, queries that might otherwise be identical end up polluting the query plan cache, both on the EF stack and on the database server, and do not get reutilized unless the same constants are used in a subsequent query execution.</span></span> <span data-ttu-id="4db1f-530">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="4db1f-530">For example:</span></span>

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="4db1f-531">W tym przykładzie, za każdym razem, gdy to zapytanie jest wykonywane z inną wartością dla identyfikatora, zapytanie zostanie skompilowane do nowego planu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-531">In this example, each time this query is executed with a different value for id the query will be compiled into a new plan.</span></span>

<span data-ttu-id="4db1f-532">W szczególności należy zwrócić uwagę na użycie pomijania i podjąć podczas wykonywania stronicowania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-532">In particular pay attention to the use of Skip and Take when doing paging.</span></span> <span data-ttu-id="4db1f-533">W EF6 te metody mają Przeciążenie lambda, które efektywnie czynią buforowanym planem zapytań, ponieważ program EF może przechwytywać zmienne przesłane do tych metod i przetłumaczać je na parametry SqlParameters.</span><span class="sxs-lookup"><span data-stu-id="4db1f-533">In EF6 these methods have a lambda overload that effectively makes the cached query plan reusable because EF can capture variables passed to these methods and translate them to SQLparameters.</span></span> <span data-ttu-id="4db1f-534">Pozwala to również zachować oczyszczarkę pamięci podręcznej, ponieważ w przeciwnym razie każde zapytanie o inną stałą dla pozycji Pomiń i zrób spowoduje uzyskanie własnego wpisu pamięci podręcznej planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-534">This also helps keep the cache cleaner since otherwise each query with a different constant for Skip and Take would get its own query plan cache entry.</span></span>

<span data-ttu-id="4db1f-535">Rozważmy poniższy kod, który jest optymalny, ale jest przeznaczony tylko do exemplify tej klasy zapytań:</span><span class="sxs-lookup"><span data-stu-id="4db1f-535">Consider the following code, which is suboptimal but is only meant to exemplify this class of queries:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="4db1f-536">Szybsza wersja tego samego kodu będzie wymagała wywołania pominięcia z wyrażeniem lambda:</span><span class="sxs-lookup"><span data-stu-id="4db1f-536">A faster version of this same code would involve calling Skip with a lambda:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="4db1f-537">Drugi fragment kodu może działać do 11% szybciej, ponieważ ten sam plan zapytania jest używany przy każdym uruchomieniu zapytania, co oszczędza czas procesora i zapobiega zanieczyszczaniu pamięci podręcznej zapytań.</span><span class="sxs-lookup"><span data-stu-id="4db1f-537">The second snippet may run up to 11% faster because the same query plan is used every time the query is run, which saves CPU time and avoids polluting the query cache.</span></span> <span data-ttu-id="4db1f-538">Ponadto, ponieważ parametr do pominięcia znajduje się w zamknięciu, kod może wyglądać następująco:</span><span class="sxs-lookup"><span data-stu-id="4db1f-538">Furthermore, because the parameter to Skip is in a closure the code might as well look like this now:</span></span>

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a><span data-ttu-id="4db1f-539">4,3 przy użyciu właściwości niemapowanego obiektu</span><span class="sxs-lookup"><span data-stu-id="4db1f-539">4.3 Using the properties of a non-mapped object</span></span>

<span data-ttu-id="4db1f-540">Gdy zapytanie używa właściwości niemapowanego typu obiektu jako parametru, zapytanie nie zostanie zapisane w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-540">When a query uses the properties of a non-mapped object type as a parameter then the query will not get cached.</span></span> <span data-ttu-id="4db1f-541">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="4db1f-541">For example:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

<span data-ttu-id="4db1f-542">W tym przykładzie Załóżmy, że Klasa unzamapowanytype nie jest częścią modelu Entity.</span><span class="sxs-lookup"><span data-stu-id="4db1f-542">In this example, assume that class NonMappedType is not part of the Entity model.</span></span> <span data-ttu-id="4db1f-543">To zapytanie można łatwo zmienić, aby nie używało niemapowanego typu, a zamiast tego użyć zmiennej lokalnej jako parametru do zapytania:</span><span class="sxs-lookup"><span data-stu-id="4db1f-543">This query can easily be changed to not use a non-mapped type and instead use a local variable as the parameter to the query:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="4db1f-544">W takim przypadku zapytanie będzie mogło być dostępne w pamięci podręcznej i będzie korzystać z pamięci podręcznej planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-544">In this case, the query will be able to get cached and will benefit from the query plan cache.</span></span>

### <a name="44-linking-to-queries-that-require-recompiling"></a><span data-ttu-id="4db1f-545">4,4 Łączenie z zapytaniami wymagającymi ponownego kompilowania</span><span class="sxs-lookup"><span data-stu-id="4db1f-545">4.4 Linking to queries that require recompiling</span></span>

<span data-ttu-id="4db1f-546">Zgodnie z powyższym przykładem, jeśli masz drugie zapytanie, które opiera się na zapytaniu, które musi zostać ponownie skompilowane, całe drugie zapytanie zostanie również ponownie skompilowane.</span><span class="sxs-lookup"><span data-stu-id="4db1f-546">Following the same example as above, if you have a second query that relies on a query that needs to be recompiled, your entire second query will also be recompiled.</span></span> <span data-ttu-id="4db1f-547">Oto przykład ilustrujący ten scenariusz:</span><span class="sxs-lookup"><span data-stu-id="4db1f-547">Here’s an example to illustrate this scenario:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

<span data-ttu-id="4db1f-548">Przykładem jest ogólny, ale ilustruje to, jak łączenie z firstQuery powoduje, że secondQuery nie można uzyskać pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-548">The example is generic, but it illustrates how linking to firstQuery is causing secondQuery to be unable to get cached.</span></span> <span data-ttu-id="4db1f-549">Jeśli firstQuery nie był zapytaniem wymagającym ponownej kompilacji, secondQuery zostałyby zapisane w pamięci podręcznej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-549">If firstQuery had not been a query that requires recompiling, then secondQuery would have been cached.</span></span>

## <a name="5-notracking-queries"></a><span data-ttu-id="4db1f-550">5 zapytań NoTracking</span><span class="sxs-lookup"><span data-stu-id="4db1f-550">5 NoTracking Queries</span></span>

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a><span data-ttu-id="4db1f-551">5,1 wyłączanie śledzenia zmian w celu ograniczenia kosztów zarządzania stanem</span><span class="sxs-lookup"><span data-stu-id="4db1f-551">5.1 Disabling change tracking to reduce state management overhead</span></span>

<span data-ttu-id="4db1f-552">Jeśli jesteś w scenariuszu tylko do odczytu i chcesz uniknąć narzutów ładowania obiektów do obiektu ObjectStateManager, możesz wydać zapytania "Brak śledzenia".</span><span class="sxs-lookup"><span data-stu-id="4db1f-552">If you are in a read-only scenario and want to avoid the overhead of loading the objects into the ObjectStateManager, you can issue "No Tracking" queries.</span></span><span data-ttu-id="4db1f-553">  Śledzenie zmian można wyłączyć na poziomie zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-553">  Change tracking can be disabled at the query level.</span></span>

<span data-ttu-id="4db1f-554">Należy pamiętać, że wyłączenie śledzenia zmian pozwala skutecznie wyłączyć pamięć podręczną obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-554">Note though that by disabling change tracking you are effectively turning off the object cache.</span></span> <span data-ttu-id="4db1f-555">Podczas wykonywania zapytania o jednostkę nie można pominąć materializację przez ściąganie poprzednio wykorzystanych wyników zapytania z obiektu ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="4db1f-555">When you query for an entity, we can't skip materialization by pulling the previously-materialized query results from the ObjectStateManager.</span></span> <span data-ttu-id="4db1f-556">Jeśli wykonujesz wielokrotnie zapytania dotyczące tych samych jednostek w tym samym kontekście, możesz ostatecznie zobaczyć korzyść wydajności z włączenia śledzenia zmian.</span><span class="sxs-lookup"><span data-stu-id="4db1f-556">If you are repeatedly querying for the same entities on the same context, you might actually see a performance benefit from enabling change tracking.</span></span>

<span data-ttu-id="4db1f-557">Podczas wykonywania zapytań za pomocą wystąpień obiektu ObjectContext, ObjectQuery i ObjectSet zapamiętają MergeOption po jej ustawieniu, a zapytania, które są tworzone na nich, będą dziedziczyć efektywną MergeOption zapytania nadrzędnego.</span><span class="sxs-lookup"><span data-stu-id="4db1f-557">When querying using ObjectContext, ObjectQuery and ObjectSet instances will remember a MergeOption once it is set, and queries that are composed on them will inherit the effective MergeOption of the parent query.</span></span> <span data-ttu-id="4db1f-558">W przypadku korzystania z DbContext śledzenia można wyłączyć, wywołując modyfikator AsNoTracking () na Nieogólnymi.</span><span class="sxs-lookup"><span data-stu-id="4db1f-558">When using DbContext, tracking can be disabled by calling the AsNoTracking() modifier on the DbSet.</span></span>

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a><span data-ttu-id="4db1f-559">5.1.1 wyłączenie śledzenia zmian dla zapytania podczas korzystania z DbContext</span><span class="sxs-lookup"><span data-stu-id="4db1f-559">5.1.1 Disabling change tracking for a query when using DbContext</span></span>

<span data-ttu-id="4db1f-560">Można przełączyć tryb zapytania na NoTracking poprzez łańcuch wywołania metody AsNoTracking () w zapytaniu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-560">You can switch the mode of a query to NoTracking by chaining a call to the AsNoTracking() method in the query.</span></span> <span data-ttu-id="4db1f-561">W przeciwieństwie do ObjectQuery, klasy Nieogólnymi i DBQuery w interfejsie API DbContext nie mają właściwości mutable dla MergeOption.</span><span class="sxs-lookup"><span data-stu-id="4db1f-561">Unlike ObjectQuery, the DbSet and DbQuery classes in the DbContext API don’t have a mutable property for the MergeOption.</span></span>

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a><span data-ttu-id="4db1f-562">5.1.2 Wyłączenie śledzenia zmian na poziomie zapytania przy użyciu obiektu ObjectContext</span><span class="sxs-lookup"><span data-stu-id="4db1f-562">5.1.2 Disabling change tracking at the query level using ObjectContext</span></span>

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a><span data-ttu-id="4db1f-563">5.1.3 wyłączenie śledzenia zmian dla całego zestawu jednostek przy użyciu obiektu ObjectContext</span><span class="sxs-lookup"><span data-stu-id="4db1f-563">5.1.3 Disabling change tracking for an entire entity set using ObjectContext</span></span>

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a><span data-ttu-id="4db1f-564">5,2 metryki testów ukazujące korzyść wydajności dla zapytań NoTracking</span><span class="sxs-lookup"><span data-stu-id="4db1f-564">5.2 Test Metrics demonstrating the performance benefit of NoTracking queries</span></span>

<span data-ttu-id="4db1f-565">W tym teście Przyjrzyjmy się kosztowi wypełniania obiektu ObjectStateManager, porównując śledzenie z zapytaniami NoTracking model systemu Navision.</span><span class="sxs-lookup"><span data-stu-id="4db1f-565">In this test we look at the cost of filling the ObjectStateManager by comparing Tracking to NoTracking queries for the Navision model.</span></span> <span data-ttu-id="4db1f-566">Zapoznaj się z załącznikiem opis modelu systemu Navision i typy zapytań, które zostały wykonane.</span><span class="sxs-lookup"><span data-stu-id="4db1f-566">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="4db1f-567">W tym teście wykonujemy iterację na liście zapytań i wykonują każde jeden raz.</span><span class="sxs-lookup"><span data-stu-id="4db1f-567">In this test, we iterate through the list of queries and execute each one once.</span></span> <span data-ttu-id="4db1f-568">Uruchomiono dwie odmiany testu, raz z zapytania NoTracking i raz z domyślną opcją scalania "AppendOnly".</span><span class="sxs-lookup"><span data-stu-id="4db1f-568">We ran two variations of the test, once with NoTracking queries and once with the default merge option of "AppendOnly".</span></span> <span data-ttu-id="4db1f-569">Każda zmiana została uruchomiona 3 razy i ma wartość średnia dla przebiegów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-569">We ran each variation 3 times and take the mean value of the runs.</span></span> <span data-ttu-id="4db1f-570">Między testami czyścimy pamięć podręczną zapytań na SQL Server i zmniejszamy bazę danych tempdb, uruchamiając następujące polecenia:</span><span class="sxs-lookup"><span data-stu-id="4db1f-570">Between the tests we clear the query cache on the SQL Server and shrink the tempdb by running the following commands:</span></span>

1.  <span data-ttu-id="4db1f-571">POLECENIE DBCC DROPCLEANBUFFERS</span><span class="sxs-lookup"><span data-stu-id="4db1f-571">DBCC DROPCLEANBUFFERS</span></span>
2.  <span data-ttu-id="4db1f-572">POLECENIE DBCC FREEPROCCACHE</span><span class="sxs-lookup"><span data-stu-id="4db1f-572">DBCC FREEPROCCACHE</span></span>
3.  <span data-ttu-id="4db1f-573">DBCC SHRINKDATABASE (tempdb, 0)</span><span class="sxs-lookup"><span data-stu-id="4db1f-573">DBCC SHRINKDATABASE (tempdb, 0)</span></span>

<span data-ttu-id="4db1f-574">Wyniki testów, mediana nad 3 uruchomieniami:</span><span class="sxs-lookup"><span data-stu-id="4db1f-574">Test Results, median over 3 runs:</span></span>

|                        | <span data-ttu-id="4db1f-575">BRAK ŚLEDZENIA — ZESTAW ROBOCZY</span><span class="sxs-lookup"><span data-stu-id="4db1f-575">NO TRACKING – WORKING SET</span></span> | <span data-ttu-id="4db1f-576">BEZ ŚLEDZENIA — CZAS</span><span class="sxs-lookup"><span data-stu-id="4db1f-576">NO TRACKING – TIME</span></span> | <span data-ttu-id="4db1f-577">TYLKO DOŁĄCZANIE — ZESTAW ROBOCZY</span><span class="sxs-lookup"><span data-stu-id="4db1f-577">APPEND ONLY – WORKING SET</span></span> | <span data-ttu-id="4db1f-578">TYLKO DOŁĄCZ — CZAS</span><span class="sxs-lookup"><span data-stu-id="4db1f-578">APPEND ONLY – TIME</span></span> |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| <span data-ttu-id="4db1f-579">**Entity Framework 5**</span><span class="sxs-lookup"><span data-stu-id="4db1f-579">**Entity Framework 5**</span></span> | <span data-ttu-id="4db1f-580">460361728</span><span class="sxs-lookup"><span data-stu-id="4db1f-580">460361728</span></span>                 | <span data-ttu-id="4db1f-581">1163536 MS</span><span class="sxs-lookup"><span data-stu-id="4db1f-581">1163536 ms</span></span>         | <span data-ttu-id="4db1f-582">596545536</span><span class="sxs-lookup"><span data-stu-id="4db1f-582">596545536</span></span>                 | <span data-ttu-id="4db1f-583">1273042 MS</span><span class="sxs-lookup"><span data-stu-id="4db1f-583">1273042 ms</span></span>         |
| <span data-ttu-id="4db1f-584">**Entity Framework 6**</span><span class="sxs-lookup"><span data-stu-id="4db1f-584">**Entity Framework 6**</span></span> | <span data-ttu-id="4db1f-585">647127040</span><span class="sxs-lookup"><span data-stu-id="4db1f-585">647127040</span></span>                 | <span data-ttu-id="4db1f-586">190228 MS</span><span class="sxs-lookup"><span data-stu-id="4db1f-586">190228 ms</span></span>          | <span data-ttu-id="4db1f-587">832798720</span><span class="sxs-lookup"><span data-stu-id="4db1f-587">832798720</span></span>                 | <span data-ttu-id="4db1f-588">195521 MS</span><span class="sxs-lookup"><span data-stu-id="4db1f-588">195521 ms</span></span>          |

<span data-ttu-id="4db1f-589">Program Entity Framework 5 będzie miał mniejsze ilości pamięci na końcu uruchomienia niż Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="4db1f-589">Entity Framework 5 will have a smaller memory footprint at the end of the run than Entity Framework 6 does.</span></span> <span data-ttu-id="4db1f-590">Dodatkowa pamięć używana przez Entity Framework 6 to wynik dodatkowych struktur pamięci i kodu, który umożliwia korzystanie z nowych funkcji i lepszą wydajność.</span><span class="sxs-lookup"><span data-stu-id="4db1f-590">The additional memory consumed by Entity Framework 6 is the result of additional memory structures and code that enable new features and better performance.</span></span>

<span data-ttu-id="4db1f-591">W przypadku korzystania z obiektu ObjectStateManager istnieje również wyraźna różnica w pamięci.</span><span class="sxs-lookup"><span data-stu-id="4db1f-591">There’s also a clear difference in memory footprint when using the ObjectStateManager.</span></span> <span data-ttu-id="4db1f-592">Entity Framework 5 zwiększono swoje rozmiary o 30% podczas śledzenia wszystkich jednostek, z których korzystamy z bazy danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-592">Entity Framework 5 increased its footprint by 30% when keeping track of all the entities we materialized from the database.</span></span> <span data-ttu-id="4db1f-593">Entity Framework 6 zwiększono jego rozmiary o 28% w tym czasie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-593">Entity Framework 6 increased its footprint by 28% when doing so.</span></span>

<span data-ttu-id="4db1f-594">W czasie Entity Framework 6 przeprowadzi Entity Framework 5 w tym teście o duży margines.</span><span class="sxs-lookup"><span data-stu-id="4db1f-594">In terms of time, Entity Framework 6 outperforms Entity Framework 5 in this test by a large margin.</span></span> <span data-ttu-id="4db1f-595">Entity Framework 6 zakończył test w około 16% czasu zużyty przez Entity Framework 5.</span><span class="sxs-lookup"><span data-stu-id="4db1f-595">Entity Framework 6 completed the test in roughly 16% of the time consumed by Entity Framework 5.</span></span> <span data-ttu-id="4db1f-596">Ponadto Entity Framework 5 trwa o 9% więcej czasu, gdy obiekt ObjectStateManager jest używany.</span><span class="sxs-lookup"><span data-stu-id="4db1f-596">Additionally, Entity Framework 5 takes 9% more time to complete when the ObjectStateManager is being used.</span></span> <span data-ttu-id="4db1f-597">W porównaniu Entity Framework 6 jest używany przez 3% więcej czasu przy użyciu obiektu ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="4db1f-597">In comparison, Entity Framework 6 is using 3% more time when using the ObjectStateManager.</span></span>

## <a name="6-query-execution-options"></a><span data-ttu-id="4db1f-598">6 opcji wykonywania zapytania</span><span class="sxs-lookup"><span data-stu-id="4db1f-598">6 Query Execution Options</span></span>

<span data-ttu-id="4db1f-599">Entity Framework oferuje kilka różnych sposobów wykonywania zapytań.</span><span class="sxs-lookup"><span data-stu-id="4db1f-599">Entity Framework offers several different ways to query.</span></span> <span data-ttu-id="4db1f-600">Zapoznaj się z następującymi opcjami, porównaj zalety i wady każdego z nich i sprawdź ich charakterystykę wydajności:</span><span class="sxs-lookup"><span data-stu-id="4db1f-600">We'll take a look at the following options, compare the pros and cons of each, and examine their performance characteristics:</span></span>

-   <span data-ttu-id="4db1f-601">LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="4db1f-601">LINQ to Entities.</span></span>
-   <span data-ttu-id="4db1f-602">Brak śledzenia LINQ to Entities.</span><span class="sxs-lookup"><span data-stu-id="4db1f-602">No Tracking LINQ to Entities.</span></span>
-   <span data-ttu-id="4db1f-603">Entity SQL w ObjectQuery.</span><span class="sxs-lookup"><span data-stu-id="4db1f-603">Entity SQL over an ObjectQuery.</span></span>
-   <span data-ttu-id="4db1f-604">Entity SQL w EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="4db1f-604">Entity SQL over an EntityCommand.</span></span>
-   <span data-ttu-id="4db1f-605">ExecuteStoreQuery.</span><span class="sxs-lookup"><span data-stu-id="4db1f-605">ExecuteStoreQuery.</span></span>
-   <span data-ttu-id="4db1f-606">SqlQuery.</span><span class="sxs-lookup"><span data-stu-id="4db1f-606">SqlQuery.</span></span>
-   <span data-ttu-id="4db1f-607">CompiledQuery.</span><span class="sxs-lookup"><span data-stu-id="4db1f-607">CompiledQuery.</span></span>

### <a name="61-linq-to-entities-queries"></a><span data-ttu-id="4db1f-608">6,1 zapytań LINQ to Entities</span><span class="sxs-lookup"><span data-stu-id="4db1f-608">6.1       LINQ to Entities queries</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="4db1f-609">**Formaty**</span><span class="sxs-lookup"><span data-stu-id="4db1f-609">**Pros**</span></span>

-   <span data-ttu-id="4db1f-610">Odpowiednie dla operacji CUD.</span><span class="sxs-lookup"><span data-stu-id="4db1f-610">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="4db1f-611">W pełni materiałowe obiekty.</span><span class="sxs-lookup"><span data-stu-id="4db1f-611">Fully materialized objects.</span></span>
-   <span data-ttu-id="4db1f-612">Najprostszym sposobem pisać składnią wbudowaną w język programowania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-612">Simplest to write with syntax built into the programming language.</span></span>
-   <span data-ttu-id="4db1f-613">Dobra wydajność.</span><span class="sxs-lookup"><span data-stu-id="4db1f-613">Good performance.</span></span>

<span data-ttu-id="4db1f-614">**Wada**</span><span class="sxs-lookup"><span data-stu-id="4db1f-614">**Cons**</span></span>

-   <span data-ttu-id="4db1f-615">Niektóre ograniczenia techniczne, takie jak:</span><span class="sxs-lookup"><span data-stu-id="4db1f-615">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="4db1f-616">Wzorce używające DefaultIfEmpty dla zapytań SPRZĘŻENIa zewnętrznego powodują bardziej skomplikowane zapytania niż proste instrukcje zewnętrznego SPRZĘŻENIa w Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="4db1f-616">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="4db1f-617">Nadal nie można używać takich jak z ogólnym dopasowaniem do wzorca.</span><span class="sxs-lookup"><span data-stu-id="4db1f-617">You still can’t use LIKE with general pattern matching.</span></span>

### <a name="62-no-tracking-linq-to-entities-queries"></a><span data-ttu-id="4db1f-618">6,2 Brak śledzenia zapytań LINQ to Entities</span><span class="sxs-lookup"><span data-stu-id="4db1f-618">6.2       No Tracking LINQ to Entities queries</span></span>

<span data-ttu-id="4db1f-619">Gdy kontekst dziedziczy:</span><span class="sxs-lookup"><span data-stu-id="4db1f-619">When the context derives ObjectContext:</span></span>

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="4db1f-620">Gdy kontekst dziedziczy DbContext:</span><span class="sxs-lookup"><span data-stu-id="4db1f-620">When the context derives DbContext:</span></span>

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="4db1f-621">**Formaty**</span><span class="sxs-lookup"><span data-stu-id="4db1f-621">**Pros**</span></span>

-   <span data-ttu-id="4db1f-622">Zwiększona wydajność przez zwykłe zapytania LINQ.</span><span class="sxs-lookup"><span data-stu-id="4db1f-622">Improved performance over regular LINQ queries.</span></span>
-   <span data-ttu-id="4db1f-623">W pełni materiałowe obiekty.</span><span class="sxs-lookup"><span data-stu-id="4db1f-623">Fully materialized objects.</span></span>
-   <span data-ttu-id="4db1f-624">Najprostszym sposobem pisać składnią wbudowaną w język programowania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-624">Simplest to write with syntax built into the programming language.</span></span>

<span data-ttu-id="4db1f-625">**Wada**</span><span class="sxs-lookup"><span data-stu-id="4db1f-625">**Cons**</span></span>

-   <span data-ttu-id="4db1f-626">Nieodpowiednie dla operacji CUD.</span><span class="sxs-lookup"><span data-stu-id="4db1f-626">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="4db1f-627">Niektóre ograniczenia techniczne, takie jak:</span><span class="sxs-lookup"><span data-stu-id="4db1f-627">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="4db1f-628">Wzorce używające DefaultIfEmpty dla zapytań SPRZĘŻENIa zewnętrznego powodują bardziej skomplikowane zapytania niż proste instrukcje zewnętrznego SPRZĘŻENIa w Entity SQL.</span><span class="sxs-lookup"><span data-stu-id="4db1f-628">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="4db1f-629">Nadal nie można używać takich jak z ogólnym dopasowaniem do wzorca.</span><span class="sxs-lookup"><span data-stu-id="4db1f-629">You still can’t use LIKE with general pattern matching.</span></span>

<span data-ttu-id="4db1f-630">Należy zauważyć, że zapytania, które właściwości skalarne projektu nie są śledzone, nawet jeśli nie jest określone NoTracking.</span><span class="sxs-lookup"><span data-stu-id="4db1f-630">Note that queries that project scalar properties are not tracked even if the NoTracking is not specified.</span></span> <span data-ttu-id="4db1f-631">Na przykład:</span><span class="sxs-lookup"><span data-stu-id="4db1f-631">For example:</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

<span data-ttu-id="4db1f-632">To konkretne zapytanie nie określa jawnie elementu NoTracking, ale ponieważ nie materializacji typu, który jest znany przez menedżera stanu obiektów, wówczas materiałowy wynik nie jest śledzony.</span><span class="sxs-lookup"><span data-stu-id="4db1f-632">This particular query doesn’t explicitly specify being NoTracking, but since it’s not materializing a type that’s known to the object state manager then the materialized result is not tracked.</span></span>

### <a name="63-entity-sql-over-an-objectquery"></a><span data-ttu-id="4db1f-633">6,3 Entity SQL w ObjectQuery</span><span class="sxs-lookup"><span data-stu-id="4db1f-633">6.3       Entity SQL over an ObjectQuery</span></span>

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

<span data-ttu-id="4db1f-634">**Formaty**</span><span class="sxs-lookup"><span data-stu-id="4db1f-634">**Pros**</span></span>

-   <span data-ttu-id="4db1f-635">Odpowiednie dla operacji CUD.</span><span class="sxs-lookup"><span data-stu-id="4db1f-635">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="4db1f-636">W pełni materiałowe obiekty.</span><span class="sxs-lookup"><span data-stu-id="4db1f-636">Fully materialized objects.</span></span>
-   <span data-ttu-id="4db1f-637">Obsługuje buforowanie planu zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-637">Supports query plan caching.</span></span>

<span data-ttu-id="4db1f-638">**Wada**</span><span class="sxs-lookup"><span data-stu-id="4db1f-638">**Cons**</span></span>

-   <span data-ttu-id="4db1f-639">Obejmuje ciągi kwerend tekstowych, które są bardziej podatne na błędy użytkownika niż konstrukcje zapytań wbudowane w język.</span><span class="sxs-lookup"><span data-stu-id="4db1f-639">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>

### <a name="64-entity-sql-over-an-entity-command"></a><span data-ttu-id="4db1f-640">6,4 Entity SQL za pomocą polecenia Entity</span><span class="sxs-lookup"><span data-stu-id="4db1f-640">6.4       Entity SQL over an Entity Command</span></span>

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

<span data-ttu-id="4db1f-641">**Formaty**</span><span class="sxs-lookup"><span data-stu-id="4db1f-641">**Pros**</span></span>

-   <span data-ttu-id="4db1f-642">Obsługuje buforowanie planu zapytania w programie .NET 4,0 (buforowanie planu jest obsługiwane przez wszystkie inne typy zapytań w programie .NET 4,5).</span><span class="sxs-lookup"><span data-stu-id="4db1f-642">Supports query plan caching in .NET 4.0 (plan caching is supported by all other query types in .NET 4.5).</span></span>

<span data-ttu-id="4db1f-643">**Wada**</span><span class="sxs-lookup"><span data-stu-id="4db1f-643">**Cons**</span></span>

-   <span data-ttu-id="4db1f-644">Obejmuje ciągi kwerend tekstowych, które są bardziej podatne na błędy użytkownika niż konstrukcje zapytań wbudowane w język.</span><span class="sxs-lookup"><span data-stu-id="4db1f-644">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>
-   <span data-ttu-id="4db1f-645">Nieodpowiednie dla operacji CUD.</span><span class="sxs-lookup"><span data-stu-id="4db1f-645">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="4db1f-646">Wyniki nie są automatycznie materiałowe i muszą zostać odczytane z czytnika danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-646">Results are not automatically materialized, and must be read from the data reader.</span></span>

### <a name="65-sqlquery-and-executestorequery"></a><span data-ttu-id="4db1f-647">6,5 sqlQuery i ExecuteStoreQuery</span><span class="sxs-lookup"><span data-stu-id="4db1f-647">6.5       SqlQuery and ExecuteStoreQuery</span></span>

<span data-ttu-id="4db1f-648">SqlQuery w bazie danych:</span><span class="sxs-lookup"><span data-stu-id="4db1f-648">SqlQuery on Database:</span></span>

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

<span data-ttu-id="4db1f-649">SqlQuery w Nieogólnymi:</span><span class="sxs-lookup"><span data-stu-id="4db1f-649">SqlQuery on DbSet:</span></span>

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

<span data-ttu-id="4db1f-650">ExecyteStoreQuery:</span><span class="sxs-lookup"><span data-stu-id="4db1f-650">ExecyteStoreQuery:</span></span>

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

<span data-ttu-id="4db1f-651">**Formaty**</span><span class="sxs-lookup"><span data-stu-id="4db1f-651">**Pros**</span></span>

-   <span data-ttu-id="4db1f-652">Zazwyczaj najszybszą wydajność, ponieważ kompilator planu jest pomijany.</span><span class="sxs-lookup"><span data-stu-id="4db1f-652">Generally fastest performance since plan compiler is bypassed.</span></span>
-   <span data-ttu-id="4db1f-653">W pełni materiałowe obiekty.</span><span class="sxs-lookup"><span data-stu-id="4db1f-653">Fully materialized objects.</span></span>
-   <span data-ttu-id="4db1f-654">Odpowiednie dla operacji CUD, gdy są używane z Nieogólnymi.</span><span class="sxs-lookup"><span data-stu-id="4db1f-654">Suitable for CUD operations when used from the DbSet.</span></span>

<span data-ttu-id="4db1f-655">**Wada**</span><span class="sxs-lookup"><span data-stu-id="4db1f-655">**Cons**</span></span>

-   <span data-ttu-id="4db1f-656">Zapytanie jest tekstowe i podatne na błędy.</span><span class="sxs-lookup"><span data-stu-id="4db1f-656">Query is textual and error prone.</span></span>
-   <span data-ttu-id="4db1f-657">Zapytanie jest powiązane z określonym zapleczem przy użyciu semantyki magazynu zamiast semantyki koncepcyjnej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-657">Query is tied to a specific backend by using store semantics instead of conceptual semantics.</span></span>
-   <span data-ttu-id="4db1f-658">Gdy jest obecny dziedziczenie, zapytanie Handcrafted musi uwzględnić warunki mapowania dla żądanego typu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-658">When inheritance is present, handcrafted query needs to account for mapping conditions for the type requested.</span></span>

### <a name="66-compiledquery"></a><span data-ttu-id="4db1f-659">6,6 CompiledQuery</span><span class="sxs-lookup"><span data-stu-id="4db1f-659">6.6       CompiledQuery</span></span>

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

<span data-ttu-id="4db1f-660">**Formaty**</span><span class="sxs-lookup"><span data-stu-id="4db1f-660">**Pros**</span></span>

-   <span data-ttu-id="4db1f-661">Zapewnia wzrost wydajności do 7% w porównaniu do zwykłych zapytań LINQ.</span><span class="sxs-lookup"><span data-stu-id="4db1f-661">Provides up to a 7% performance improvement over regular LINQ queries.</span></span>
-   <span data-ttu-id="4db1f-662">W pełni materiałowe obiekty.</span><span class="sxs-lookup"><span data-stu-id="4db1f-662">Fully materialized objects.</span></span>
-   <span data-ttu-id="4db1f-663">Odpowiednie dla operacji CUD.</span><span class="sxs-lookup"><span data-stu-id="4db1f-663">Suitable for CUD operations.</span></span>

<span data-ttu-id="4db1f-664">**Wada**</span><span class="sxs-lookup"><span data-stu-id="4db1f-664">**Cons**</span></span>

-   <span data-ttu-id="4db1f-665">Zwiększona złożoność i narzuty związane z programowaniem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-665">Increased complexity and programming overhead.</span></span>
-   <span data-ttu-id="4db1f-666">Zwiększenie wydajności jest tracone podczas redagowania na skompilowanym zapytaniu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-666">The performance improvement is lost when composing on top of a compiled query.</span></span>
-   <span data-ttu-id="4db1f-667">Niektóre zapytania LINQ nie mogą być zapisywane jako CompiledQuery — na przykład projekcje typów anonimowych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-667">Some LINQ queries can't be written as a CompiledQuery - for example, projections of anonymous types.</span></span>

### <a name="67-performance-comparison-of-different-query-options"></a><span data-ttu-id="4db1f-668">Porównanie wydajności 6,7 różnych opcji zapytania</span><span class="sxs-lookup"><span data-stu-id="4db1f-668">6.7       Performance Comparison of different query options</span></span>

<span data-ttu-id="4db1f-669">Proste mikrotesty, w których nie upłynął limit czasu tworzenia kontekstu, zostały wprowadzone do testu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-669">Simple microbenchmarks where the context creation was not timed were put to the test.</span></span> <span data-ttu-id="4db1f-670">Mierzy zapytania o 5000 razy dla zestawu niebuforowanych jednostek w środowisku kontrolowanym.</span><span class="sxs-lookup"><span data-stu-id="4db1f-670">We measured querying 5000 times for a set of non-cached entities in a controlled environment.</span></span> <span data-ttu-id="4db1f-671">Te liczby mają być pobierane z ostrzeżeniem: nie odzwierciedlają rzeczywistej liczby wyprodukowanej przez aplikację, ale zamiast tego są bardzo precyzyjne pomiary, jaka jest różnica wydajności, gdy porównywane są różne opcje zapytania jabłka do jabłek, z wyłączeniem kosztów tworzenia nowego kontekstu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-671">These numbers are to be taken with a warning: they do not reflect actual numbers produced by an application, but instead they are a very accurate measurement of how much of a performance difference there is when different querying options are compared apples-to-apples, excluding the cost of creating a new context.</span></span>

| <span data-ttu-id="4db1f-672">BIEŻĄCO</span><span class="sxs-lookup"><span data-stu-id="4db1f-672">EF</span></span>  | <span data-ttu-id="4db1f-673">Testowanie</span><span class="sxs-lookup"><span data-stu-id="4db1f-673">Test</span></span>                                 | <span data-ttu-id="4db1f-674">Czas (MS)</span><span class="sxs-lookup"><span data-stu-id="4db1f-674">Time (ms)</span></span> | <span data-ttu-id="4db1f-675">Memory (Pamięć)</span><span class="sxs-lookup"><span data-stu-id="4db1f-675">Memory</span></span>   |
|:----|:-------------------------------------|:----------|:---------|
| <span data-ttu-id="4db1f-676">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-676">EF5</span></span> | <span data-ttu-id="4db1f-677">Obiekt ObjectContext ESQL</span><span class="sxs-lookup"><span data-stu-id="4db1f-677">ObjectContext ESQL</span></span>                   | <span data-ttu-id="4db1f-678">2414</span><span class="sxs-lookup"><span data-stu-id="4db1f-678">2414</span></span>      | <span data-ttu-id="4db1f-679">38801408</span><span class="sxs-lookup"><span data-stu-id="4db1f-679">38801408</span></span> |
| <span data-ttu-id="4db1f-680">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-680">EF5</span></span> | <span data-ttu-id="4db1f-681">Zapytanie ObjectContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-681">ObjectContext Linq Query</span></span>             | <span data-ttu-id="4db1f-682">2692</span><span class="sxs-lookup"><span data-stu-id="4db1f-682">2692</span></span>      | <span data-ttu-id="4db1f-683">38277120</span><span class="sxs-lookup"><span data-stu-id="4db1f-683">38277120</span></span> |
| <span data-ttu-id="4db1f-684">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-684">EF5</span></span> | <span data-ttu-id="4db1f-685">Brak śledzenia zapytania DbContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-685">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="4db1f-686">2818</span><span class="sxs-lookup"><span data-stu-id="4db1f-686">2818</span></span>      | <span data-ttu-id="4db1f-687">41840640</span><span class="sxs-lookup"><span data-stu-id="4db1f-687">41840640</span></span> |
| <span data-ttu-id="4db1f-688">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-688">EF5</span></span> | <span data-ttu-id="4db1f-689">Zapytanie DbContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-689">DbContext Linq Query</span></span>                 | <span data-ttu-id="4db1f-690">2930</span><span class="sxs-lookup"><span data-stu-id="4db1f-690">2930</span></span>      | <span data-ttu-id="4db1f-691">41771008</span><span class="sxs-lookup"><span data-stu-id="4db1f-691">41771008</span></span> |
| <span data-ttu-id="4db1f-692">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-692">EF5</span></span> | <span data-ttu-id="4db1f-693">Zapytanie ObjectContext LINQ bez śledzenia</span><span class="sxs-lookup"><span data-stu-id="4db1f-693">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="4db1f-694">3013</span><span class="sxs-lookup"><span data-stu-id="4db1f-694">3013</span></span>      | <span data-ttu-id="4db1f-695">38412288</span><span class="sxs-lookup"><span data-stu-id="4db1f-695">38412288</span></span> |
|     |                                      |           |          |
| <span data-ttu-id="4db1f-696">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-696">EF6</span></span> | <span data-ttu-id="4db1f-697">Obiekt ObjectContext ESQL</span><span class="sxs-lookup"><span data-stu-id="4db1f-697">ObjectContext ESQL</span></span>                   | <span data-ttu-id="4db1f-698">2059</span><span class="sxs-lookup"><span data-stu-id="4db1f-698">2059</span></span>      | <span data-ttu-id="4db1f-699">46039040</span><span class="sxs-lookup"><span data-stu-id="4db1f-699">46039040</span></span> |
| <span data-ttu-id="4db1f-700">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-700">EF6</span></span> | <span data-ttu-id="4db1f-701">Zapytanie ObjectContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-701">ObjectContext Linq Query</span></span>             | <span data-ttu-id="4db1f-702">3074</span><span class="sxs-lookup"><span data-stu-id="4db1f-702">3074</span></span>      | <span data-ttu-id="4db1f-703">45248512</span><span class="sxs-lookup"><span data-stu-id="4db1f-703">45248512</span></span> |
| <span data-ttu-id="4db1f-704">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-704">EF6</span></span> | <span data-ttu-id="4db1f-705">Brak śledzenia zapytania DbContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-705">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="4db1f-706">3125</span><span class="sxs-lookup"><span data-stu-id="4db1f-706">3125</span></span>      | <span data-ttu-id="4db1f-707">47575040</span><span class="sxs-lookup"><span data-stu-id="4db1f-707">47575040</span></span> |
| <span data-ttu-id="4db1f-708">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-708">EF6</span></span> | <span data-ttu-id="4db1f-709">Zapytanie DbContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-709">DbContext Linq Query</span></span>                 | <span data-ttu-id="4db1f-710">3420</span><span class="sxs-lookup"><span data-stu-id="4db1f-710">3420</span></span>      | <span data-ttu-id="4db1f-711">47652864</span><span class="sxs-lookup"><span data-stu-id="4db1f-711">47652864</span></span> |
| <span data-ttu-id="4db1f-712">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-712">EF6</span></span> | <span data-ttu-id="4db1f-713">Zapytanie ObjectContext LINQ bez śledzenia</span><span class="sxs-lookup"><span data-stu-id="4db1f-713">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="4db1f-714">3593</span><span class="sxs-lookup"><span data-stu-id="4db1f-714">3593</span></span>      | <span data-ttu-id="4db1f-715">45260800</span><span class="sxs-lookup"><span data-stu-id="4db1f-715">45260800</span></span> |

![EF5 mikroporównawcze, 5000 iteracji](~/ef6/media/ef5micro5000warm.png)

![EF6 mikroporównawcze, 5000 iteracji](~/ef6/media/ef6micro5000warm.png)

<span data-ttu-id="4db1f-718">Mikrotesty są bardzo poufne dla małych zmian w kodzie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-718">Microbenchmarks are very sensitive to small changes in the code.</span></span> <span data-ttu-id="4db1f-719">W takim przypadku różnica między kosztami Entity Framework 5 i Entity Framework 6 jest spowodowana dodaniem [przechwycenia](~/ef6/fundamentals/logging-and-interception.md) i zmian [transakcyjnych](~/ef6/saving/transactions.md).</span><span class="sxs-lookup"><span data-stu-id="4db1f-719">In this case, the difference between the costs of Entity Framework 5 and Entity Framework 6 are due to the addition of [interception](~/ef6/fundamentals/logging-and-interception.md) and [transactional improvements](~/ef6/saving/transactions.md).</span></span> <span data-ttu-id="4db1f-720">Te mikrotestowe numery, jednak stanowią wzmocną wizję do bardzo małego fragmentu Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-720">These microbenchmarks numbers, however, are an amplified vision into a very small fragment of what Entity Framework does.</span></span> <span data-ttu-id="4db1f-721">Rzeczywiste scenariusze zapytań ciepłej nie powinny mieć zastosowania regresji wydajności podczas uaktualniania z Entity Framework 5 do Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="4db1f-721">Real-world scenarios of warm queries should not see a performance regression when upgrading from Entity Framework 5 to Entity Framework 6.</span></span>

<span data-ttu-id="4db1f-722">Aby porównać rzeczywistą wydajność różnych opcji zapytania, utworzyliśmy 5 oddzielnych odmian testowych, w których używamy innej opcji zapytania, aby wybrać wszystkie produkty, których nazwa kategorii to "napoje".</span><span class="sxs-lookup"><span data-stu-id="4db1f-722">To compare the real-world performance of the different query options, we created 5 separate test variations where we use a different query option to select all products whose category name is "Beverages".</span></span> <span data-ttu-id="4db1f-723">Każda iteracja obejmuje koszt tworzenia kontekstu, a koszt materializacji wszystkich zwracanych jednostek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-723">Each iteration includes the cost of creating the context, and the cost of materializing all returned entities.</span></span> <span data-ttu-id="4db1f-724">10 iteracji jest wykonywanych przed upływem sumy 1000 iteracji czasowych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-724">10 iterations are run untimed before taking the sum of 1000 timed iterations.</span></span> <span data-ttu-id="4db1f-725">Wyświetlane wyniki to mediana, wykonywana z 5 przebiegów każdego testu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-725">The results shown are the median run taken from 5 runs of each test.</span></span> <span data-ttu-id="4db1f-726">Aby uzyskać więcej informacji, zobacz dodatek B, który zawiera kod dla testu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-726">For more information, see Appendix B which includes the code for the test.</span></span>

| <span data-ttu-id="4db1f-727">BIEŻĄCO</span><span class="sxs-lookup"><span data-stu-id="4db1f-727">EF</span></span>  | <span data-ttu-id="4db1f-728">Testowanie</span><span class="sxs-lookup"><span data-stu-id="4db1f-728">Test</span></span>                                        | <span data-ttu-id="4db1f-729">Czas (MS)</span><span class="sxs-lookup"><span data-stu-id="4db1f-729">Time (ms)</span></span> | <span data-ttu-id="4db1f-730">Memory (Pamięć)</span><span class="sxs-lookup"><span data-stu-id="4db1f-730">Memory</span></span>   |
|:----|:--------------------------------------------|:----------|:---------|
| <span data-ttu-id="4db1f-731">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-731">EF5</span></span> | <span data-ttu-id="4db1f-732">ObjectContext Entity — polecenie</span><span class="sxs-lookup"><span data-stu-id="4db1f-732">ObjectContext Entity Command</span></span>                | <span data-ttu-id="4db1f-733">621</span><span class="sxs-lookup"><span data-stu-id="4db1f-733">621</span></span>       | <span data-ttu-id="4db1f-734">39350272</span><span class="sxs-lookup"><span data-stu-id="4db1f-734">39350272</span></span> |
| <span data-ttu-id="4db1f-735">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-735">EF5</span></span> | <span data-ttu-id="4db1f-736">Zapytanie SQL DbContext w bazie danych</span><span class="sxs-lookup"><span data-stu-id="4db1f-736">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="4db1f-737">825</span><span class="sxs-lookup"><span data-stu-id="4db1f-737">825</span></span>       | <span data-ttu-id="4db1f-738">37519360</span><span class="sxs-lookup"><span data-stu-id="4db1f-738">37519360</span></span> |
| <span data-ttu-id="4db1f-739">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-739">EF5</span></span> | <span data-ttu-id="4db1f-740">Zapytanie magazynu ObjectContext</span><span class="sxs-lookup"><span data-stu-id="4db1f-740">ObjectContext Store Query</span></span>                   | <span data-ttu-id="4db1f-741">878</span><span class="sxs-lookup"><span data-stu-id="4db1f-741">878</span></span>       | <span data-ttu-id="4db1f-742">39460864</span><span class="sxs-lookup"><span data-stu-id="4db1f-742">39460864</span></span> |
| <span data-ttu-id="4db1f-743">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-743">EF5</span></span> | <span data-ttu-id="4db1f-744">Zapytanie ObjectContext LINQ bez śledzenia</span><span class="sxs-lookup"><span data-stu-id="4db1f-744">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="4db1f-745">969</span><span class="sxs-lookup"><span data-stu-id="4db1f-745">969</span></span>       | <span data-ttu-id="4db1f-746">38293504</span><span class="sxs-lookup"><span data-stu-id="4db1f-746">38293504</span></span> |
| <span data-ttu-id="4db1f-747">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-747">EF5</span></span> | <span data-ttu-id="4db1f-748">Zapytanie jednostki obiektu ObjectContext programu SQL using</span><span class="sxs-lookup"><span data-stu-id="4db1f-748">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="4db1f-749">1089</span><span class="sxs-lookup"><span data-stu-id="4db1f-749">1089</span></span>      | <span data-ttu-id="4db1f-750">38981632</span><span class="sxs-lookup"><span data-stu-id="4db1f-750">38981632</span></span> |
| <span data-ttu-id="4db1f-751">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-751">EF5</span></span> | <span data-ttu-id="4db1f-752">Zapytanie skompilowane obiektu ObjectContext</span><span class="sxs-lookup"><span data-stu-id="4db1f-752">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="4db1f-753">1099</span><span class="sxs-lookup"><span data-stu-id="4db1f-753">1099</span></span>      | <span data-ttu-id="4db1f-754">38682624</span><span class="sxs-lookup"><span data-stu-id="4db1f-754">38682624</span></span> |
| <span data-ttu-id="4db1f-755">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-755">EF5</span></span> | <span data-ttu-id="4db1f-756">Zapytanie ObjectContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-756">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="4db1f-757">1152</span><span class="sxs-lookup"><span data-stu-id="4db1f-757">1152</span></span>      | <span data-ttu-id="4db1f-758">38178816</span><span class="sxs-lookup"><span data-stu-id="4db1f-758">38178816</span></span> |
| <span data-ttu-id="4db1f-759">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-759">EF5</span></span> | <span data-ttu-id="4db1f-760">Brak śledzenia zapytania DbContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-760">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="4db1f-761">1208</span><span class="sxs-lookup"><span data-stu-id="4db1f-761">1208</span></span>      | <span data-ttu-id="4db1f-762">41803776</span><span class="sxs-lookup"><span data-stu-id="4db1f-762">41803776</span></span> |
| <span data-ttu-id="4db1f-763">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-763">EF5</span></span> | <span data-ttu-id="4db1f-764">Zapytanie SQL DbContext dotyczące Nieogólnymi</span><span class="sxs-lookup"><span data-stu-id="4db1f-764">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="4db1f-765">1414</span><span class="sxs-lookup"><span data-stu-id="4db1f-765">1414</span></span>      | <span data-ttu-id="4db1f-766">37982208</span><span class="sxs-lookup"><span data-stu-id="4db1f-766">37982208</span></span> |
| <span data-ttu-id="4db1f-767">EF5</span><span class="sxs-lookup"><span data-stu-id="4db1f-767">EF5</span></span> | <span data-ttu-id="4db1f-768">Zapytanie DbContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-768">DbContext Linq Query</span></span>                        | <span data-ttu-id="4db1f-769">1574</span><span class="sxs-lookup"><span data-stu-id="4db1f-769">1574</span></span>      | <span data-ttu-id="4db1f-770">41738240</span><span class="sxs-lookup"><span data-stu-id="4db1f-770">41738240</span></span> |
|     |                                             |           |          |
| <span data-ttu-id="4db1f-771">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-771">EF6</span></span> | <span data-ttu-id="4db1f-772">ObjectContext Entity — polecenie</span><span class="sxs-lookup"><span data-stu-id="4db1f-772">ObjectContext Entity Command</span></span>                | <span data-ttu-id="4db1f-773">480</span><span class="sxs-lookup"><span data-stu-id="4db1f-773">480</span></span>       | <span data-ttu-id="4db1f-774">47247360</span><span class="sxs-lookup"><span data-stu-id="4db1f-774">47247360</span></span> |
| <span data-ttu-id="4db1f-775">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-775">EF6</span></span> | <span data-ttu-id="4db1f-776">Zapytanie magazynu ObjectContext</span><span class="sxs-lookup"><span data-stu-id="4db1f-776">ObjectContext Store Query</span></span>                   | <span data-ttu-id="4db1f-777">493</span><span class="sxs-lookup"><span data-stu-id="4db1f-777">493</span></span>       | <span data-ttu-id="4db1f-778">46739456</span><span class="sxs-lookup"><span data-stu-id="4db1f-778">46739456</span></span> |
| <span data-ttu-id="4db1f-779">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-779">EF6</span></span> | <span data-ttu-id="4db1f-780">Zapytanie SQL DbContext w bazie danych</span><span class="sxs-lookup"><span data-stu-id="4db1f-780">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="4db1f-781">614</span><span class="sxs-lookup"><span data-stu-id="4db1f-781">614</span></span>       | <span data-ttu-id="4db1f-782">41607168</span><span class="sxs-lookup"><span data-stu-id="4db1f-782">41607168</span></span> |
| <span data-ttu-id="4db1f-783">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-783">EF6</span></span> | <span data-ttu-id="4db1f-784">Zapytanie ObjectContext LINQ bez śledzenia</span><span class="sxs-lookup"><span data-stu-id="4db1f-784">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="4db1f-785">684</span><span class="sxs-lookup"><span data-stu-id="4db1f-785">684</span></span>       | <span data-ttu-id="4db1f-786">46333952</span><span class="sxs-lookup"><span data-stu-id="4db1f-786">46333952</span></span> |
| <span data-ttu-id="4db1f-787">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-787">EF6</span></span> | <span data-ttu-id="4db1f-788">Zapytanie jednostki obiektu ObjectContext programu SQL using</span><span class="sxs-lookup"><span data-stu-id="4db1f-788">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="4db1f-789">767</span><span class="sxs-lookup"><span data-stu-id="4db1f-789">767</span></span>       | <span data-ttu-id="4db1f-790">48865280</span><span class="sxs-lookup"><span data-stu-id="4db1f-790">48865280</span></span> |
| <span data-ttu-id="4db1f-791">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-791">EF6</span></span> | <span data-ttu-id="4db1f-792">Zapytanie skompilowane obiektu ObjectContext</span><span class="sxs-lookup"><span data-stu-id="4db1f-792">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="4db1f-793">788</span><span class="sxs-lookup"><span data-stu-id="4db1f-793">788</span></span>       | <span data-ttu-id="4db1f-794">48467968</span><span class="sxs-lookup"><span data-stu-id="4db1f-794">48467968</span></span> |
| <span data-ttu-id="4db1f-795">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-795">EF6</span></span> | <span data-ttu-id="4db1f-796">Brak śledzenia zapytania DbContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-796">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="4db1f-797">878</span><span class="sxs-lookup"><span data-stu-id="4db1f-797">878</span></span>       | <span data-ttu-id="4db1f-798">47554560</span><span class="sxs-lookup"><span data-stu-id="4db1f-798">47554560</span></span> |
| <span data-ttu-id="4db1f-799">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-799">EF6</span></span> | <span data-ttu-id="4db1f-800">Zapytanie ObjectContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-800">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="4db1f-801">953</span><span class="sxs-lookup"><span data-stu-id="4db1f-801">953</span></span>       | <span data-ttu-id="4db1f-802">47632384</span><span class="sxs-lookup"><span data-stu-id="4db1f-802">47632384</span></span> |
| <span data-ttu-id="4db1f-803">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-803">EF6</span></span> | <span data-ttu-id="4db1f-804">Zapytanie SQL DbContext dotyczące Nieogólnymi</span><span class="sxs-lookup"><span data-stu-id="4db1f-804">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="4db1f-805">1023</span><span class="sxs-lookup"><span data-stu-id="4db1f-805">1023</span></span>      | <span data-ttu-id="4db1f-806">41992192</span><span class="sxs-lookup"><span data-stu-id="4db1f-806">41992192</span></span> |
| <span data-ttu-id="4db1f-807">EF6</span><span class="sxs-lookup"><span data-stu-id="4db1f-807">EF6</span></span> | <span data-ttu-id="4db1f-808">Zapytanie DbContext LINQ</span><span class="sxs-lookup"><span data-stu-id="4db1f-808">DbContext Linq Query</span></span>                        | <span data-ttu-id="4db1f-809">1290</span><span class="sxs-lookup"><span data-stu-id="4db1f-809">1290</span></span>      | <span data-ttu-id="4db1f-810">47529984</span><span class="sxs-lookup"><span data-stu-id="4db1f-810">47529984</span></span> |


![Iteracje EF5 ciepłych zapytań 1000](~/ef6/media/ef5warmquery1000.png)

![Iteracje EF6 ciepłych zapytań 1000](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> <span data-ttu-id="4db1f-813">W celu zapewnienia kompletności dodaliśmymy odmianę, w której wykonujemy Entity SQL zapytanie na EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="4db1f-813">For completeness, we included a variation where we execute an Entity SQL query on an EntityCommand.</span></span> <span data-ttu-id="4db1f-814">Jednak ze względu na to, że wyniki nie są istotne dla takich zapytań, porównanie nie jest koniecznie jabłek do jabłek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-814">However, because results are not materialized for such queries, the comparison isn't necessarily apples-to-apples.</span></span> <span data-ttu-id="4db1f-815">Test obejmuje bliskie przybliżenie do materializacji, aby spróbować uzyskać bardziej atrakcyjny wynik porównania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-815">The test includes a close approximation to materializing to try making the comparison fairer.</span></span>

<span data-ttu-id="4db1f-816">W tym celu należy wykonać Entity Framework 6 Entity Framework 5 z powodu ulepszeń wydajności dla kilku części stosu, takich jak znacznie jaśniejsze inicjalizacje DbContext i szybsze wyszukiwanie no__t-0T @ no__t-1.</span><span class="sxs-lookup"><span data-stu-id="4db1f-816">In this end-to-end case, Entity Framework 6 outperforms Entity Framework 5 due to performance improvements made on several parts of the stack, including a much lighter DbContext initialization and faster MetadataCollection&lt;T&gt; lookups.</span></span>

## <a name="7-design-time-performance-considerations"></a><span data-ttu-id="4db1f-817">7 zagadnienia dotyczące wydajności w czasie projektowania</span><span class="sxs-lookup"><span data-stu-id="4db1f-817">7 Design time performance considerations</span></span>

### <a name="71-inheritance-strategies"></a><span data-ttu-id="4db1f-818">7,1 strategie dziedziczenia</span><span class="sxs-lookup"><span data-stu-id="4db1f-818">7.1       Inheritance Strategies</span></span>

<span data-ttu-id="4db1f-819">W przypadku korzystania z Entity Framework jest stosowana strategia dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-819">Another performance consideration when using Entity Framework is the inheritance strategy you use.</span></span> <span data-ttu-id="4db1f-820">Entity Framework obsługuje 3 podstawowe typy dziedziczenia i ich kombinacje:</span><span class="sxs-lookup"><span data-stu-id="4db1f-820">Entity Framework supports 3 basic types of inheritance and their combinations:</span></span>

-   <span data-ttu-id="4db1f-821">Tabela na hierarchię (TPH) — gdzie poszczególne ustawienia dziedziczenia są mapowane na tabelę z kolumną rozróżniacza, aby wskazać, który konkretny typ w hierarchii jest reprezentowany w wierszu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-821">Table per Hierarchy (TPH) – where each inheritance set maps to a table with a discriminator column to indicate which particular type in the hierarchy is being represented in the row.</span></span>
-   <span data-ttu-id="4db1f-822">Tabela na typ (TPT) — gdzie każdy typ ma własną tabelę w bazie danych; tabele podrzędne definiują tylko kolumny, które nie zawierają tabeli nadrzędnej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-822">Table per Type (TPT) – where each type has its own table in the database; the child tables only define the columns that the parent table doesn’t contain.</span></span>
-   <span data-ttu-id="4db1f-823">Tabela na klasę (TPC) — gdzie każdy typ ma własną pełną tabelę w bazie danych; tabele podrzędne definiują wszystkie pola, włącznie z tymi zdefiniowanymi w typach nadrzędnych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-823">Table per Class (TPC) – where each type has its own full table in the database; the child tables define all their fields, including those defined in parent types.</span></span>

<span data-ttu-id="4db1f-824">Jeśli model używa dziedziczenia TPT, generowane zapytania będą bardziej skomplikowane niż te, które są generowane z innymi strategiami dziedziczenia, co może spowodować dłuższe czasy wykonywania w sklepie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-824">If your model uses TPT inheritance, the queries which are generated will be more complex than those that are generated with the other inheritance strategies, which may result on longer execution times on the store.</span></span><span data-ttu-id="4db1f-825">  Zazwyczaj generowanie zapytań w modelu TPT i zmaterializowania obiektów powstających zajmuje więcej czasu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-825">  It will generally take longer to generate queries over a TPT model, and to materialize the resulting objects.</span></span>

<span data-ttu-id="4db1f-826">Zobacz "zagadnienia dotyczące wydajności podczas korzystania z dziedziczenia TPT (Tabela na typ) w Entity Framework" w blogu MSDN: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-826">See the "Performance Considerations when using TPT (Table per Type) Inheritance in the Entity Framework" MSDN blog post: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.</span></span>

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a><span data-ttu-id="4db1f-827">7.1.1 unikanie TPT w aplikacjach Model First lub Code First</span><span class="sxs-lookup"><span data-stu-id="4db1f-827">7.1.1       Avoiding TPT in Model First or Code First applications</span></span>

<span data-ttu-id="4db1f-828">Gdy tworzysz model dla istniejącej bazy danych, która ma schemat TPT, nie masz wielu opcji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-828">When you create a model over an existing database that has a TPT schema, you don't have many options.</span></span> <span data-ttu-id="4db1f-829">Ale podczas tworzenia aplikacji przy użyciu Model First lub Code First należy unikać dziedziczenia TPT w przypadku problemów z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="4db1f-829">But when creating an application using Model First or Code First, you should avoid TPT inheritance for performance concerns.</span></span>

<span data-ttu-id="4db1f-830">W przypadku korzystania z Model First w Kreatorze Entity Designer zostanie TPT do dowolnego dziedziczenia w modelu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-830">When you use Model First in the Entity Designer Wizard, you will get TPT for any inheritance in your model.</span></span> <span data-ttu-id="4db1f-831">Jeśli chcesz przełączyć się do strategii TPH dziedziczenia z pierwszego modelu, można używać "jednostki projektanta bazy danych generowania Power Pack" dostępne z galerii Visual Studio ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span><span class="sxs-lookup"><span data-stu-id="4db1f-831">If you want to switch to a TPH inheritance strategy with Model First, you can use the "Entity Designer Database Generation Power Pack" available from the Visual Studio Gallery ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span></span>

<span data-ttu-id="4db1f-832">Przy użyciu Code First do konfigurowania mapowania modelu z dziedziczeniem, EF domyślnie będzie używać TPH, dlatego wszystkie jednostki w hierarchii dziedziczenia zostaną zmapowane do tej samej tabeli.</span><span class="sxs-lookup"><span data-stu-id="4db1f-832">When using Code First to configure the mapping of a model with inheritance, EF will use TPH by default, therefore all entities in the inheritance hierarchy will be mapped to the same table.</span></span> <span data-ttu-id="4db1f-833">Zobacz sekcję "Mapowanie z interfejs Fluent API" artykułu "Kodu pierwszy w jednostki Framework4.1" w MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) Aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-833">See the "Mapping with the Fluent API" section of the "Code First in Entity Framework4.1" article in MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) for more details.</span></span>

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a><span data-ttu-id="4db1f-834">7,2 uaktualnienie z EF4 w celu poprawienia czasu generowania modelu</span><span class="sxs-lookup"><span data-stu-id="4db1f-834">7.2       Upgrading from EF4 to improve model generation time</span></span>

<span data-ttu-id="4db1f-835">Specyficzna dla SQL Server poprawa algorytmu, który generuje warstwę magazynu (SSDL) modelu, jest dostępna w Entity Framework 5 i 6 oraz jako aktualizacja Entity Framework 4, gdy jest zainstalowany program Visual Studio 2010 SP1.</span><span class="sxs-lookup"><span data-stu-id="4db1f-835">A SQL Server-specific improvement to the algorithm that generates the store-layer (SSDL) of the model is available in Entity Framework 5 and 6, and as an update to Entity Framework 4 when Visual Studio 2010 SP1 is installed.</span></span> <span data-ttu-id="4db1f-836">Poniższe wyniki testów przedstawiają poprawę podczas generowania bardzo dużego modelu, w tym przypadku modelu systemu Navision.</span><span class="sxs-lookup"><span data-stu-id="4db1f-836">The following test results demonstrate the improvement when generating a very big model, in this case the Navision model.</span></span> <span data-ttu-id="4db1f-837">Aby uzyskać szczegółowe informacje na ten temat, zobacz Dodatek C.</span><span class="sxs-lookup"><span data-stu-id="4db1f-837">See Appendix C for more details about it.</span></span>

<span data-ttu-id="4db1f-838">Model zawiera 1005 zestawów jednostek i 4227 zestawów skojarzeń.</span><span class="sxs-lookup"><span data-stu-id="4db1f-838">The model contains 1005 entity sets and 4227 association sets.</span></span>

| <span data-ttu-id="4db1f-839">Konfigurowanie</span><span class="sxs-lookup"><span data-stu-id="4db1f-839">Configuration</span></span>                              | <span data-ttu-id="4db1f-840">Podział zużytego czasu</span><span class="sxs-lookup"><span data-stu-id="4db1f-840">Breakdown of time consumed</span></span>                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="4db1f-841">Visual Studio 2010, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="4db1f-841">Visual Studio 2010, Entity Framework 4</span></span>     | <span data-ttu-id="4db1f-842">Generowanie SSDL: 2 godz. 27 min</span><span class="sxs-lookup"><span data-stu-id="4db1f-842">SSDL Generation: 2 hr 27 min</span></span> <br/> <span data-ttu-id="4db1f-843">Generowanie mapowania: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-843">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-844">Generowanie CSDL: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-844">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-845">Generowanie ObjectLayer: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-845">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-846">Generowanie widoku: 2 godz. 14 min</span><span class="sxs-lookup"><span data-stu-id="4db1f-846">View Generation: 2 h 14 min</span></span> |
| <span data-ttu-id="4db1f-847">Visual Studio 2010 z dodatkiem SP1, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="4db1f-847">Visual Studio 2010 SP1, Entity Framework 4</span></span> | <span data-ttu-id="4db1f-848">Generowanie SSDL: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-848">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-849">Generowanie mapowania: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-849">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-850">Generowanie CSDL: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-850">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-851">Generowanie ObjectLayer: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-851">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-852">Generowanie widoku: 1 godz. 53 min</span><span class="sxs-lookup"><span data-stu-id="4db1f-852">View Generation: 1 hr 53 min</span></span>   |
| <span data-ttu-id="4db1f-853">Visual Studio 2013, Entity Framework 5</span><span class="sxs-lookup"><span data-stu-id="4db1f-853">Visual Studio 2013, Entity Framework 5</span></span>     | <span data-ttu-id="4db1f-854">Generowanie SSDL: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-854">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-855">Generowanie mapowania: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-855">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-856">Generowanie CSDL: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-856">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-857">Generowanie ObjectLayer: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-857">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-858">Generowanie widoku: 65 minut</span><span class="sxs-lookup"><span data-stu-id="4db1f-858">View Generation: 65 minutes</span></span>    |
| <span data-ttu-id="4db1f-859">Visual Studio 2013, Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="4db1f-859">Visual Studio 2013, Entity Framework 6</span></span>     | <span data-ttu-id="4db1f-860">Generowanie SSDL: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-860">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-861">Generowanie mapowania: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-861">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-862">Generowanie CSDL: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-862">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-863">Generowanie ObjectLayer: 1 sekunda</span><span class="sxs-lookup"><span data-stu-id="4db1f-863">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="4db1f-864">Generowanie widoku: 28 sekund.</span><span class="sxs-lookup"><span data-stu-id="4db1f-864">View Generation: 28 seconds.</span></span>   |


<span data-ttu-id="4db1f-865">Należy zauważyć, że podczas generowania SSDL, obciążenie jest niemal całkowicie wykorzystane na SQL Server, podczas gdy komputer deweloperski klienta oczekuje na wyniki z serwera.</span><span class="sxs-lookup"><span data-stu-id="4db1f-865">It's worth noting that when generating the SSDL, the load is almost entirely spent on the SQL Server, while the client development machine is waiting idle for results to come back from the server.</span></span> <span data-ttu-id="4db1f-866">Przetwarzający powinny szczególnie poprawić te ulepszenia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-866">DBAs should particularly appreciate this improvement.</span></span> <span data-ttu-id="4db1f-867">Warto również zauważyć, że zasadniczo cały koszt generowania modelu odbywa się teraz.</span><span class="sxs-lookup"><span data-stu-id="4db1f-867">It's also worth noting that essentially the entire cost of model generation takes place in View Generation now.</span></span>

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a><span data-ttu-id="4db1f-868">7,3 dzielenie dużych modeli przy użyciu Database First i Model First</span><span class="sxs-lookup"><span data-stu-id="4db1f-868">7.3       Splitting Large Models with Database First and Model First</span></span>

<span data-ttu-id="4db1f-869">W miarę wzrostu rozmiaru modelu powierzchnia projektanta zostaje zapełniony i trudno używać.</span><span class="sxs-lookup"><span data-stu-id="4db1f-869">As model size increases, the designer surface becomes cluttered and difficult to use.</span></span> <span data-ttu-id="4db1f-870">Zazwyczaj rozważamy model z ponad 300 jednostkami, które są zbyt duże, aby efektywnie korzystać z projektanta.</span><span class="sxs-lookup"><span data-stu-id="4db1f-870">We typically consider a model with more than 300 entities to be too large to effectively use the designer.</span></span> <span data-ttu-id="4db1f-871">Następujący wpis w blogu opisuje kilka opcji do dzielenia dużych modeli: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-871">The following blog post describes several options for splitting large models: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.</span></span>

<span data-ttu-id="4db1f-872">Wpis został zapisany dla pierwszej wersji Entity Framework, ale kroki nadal mają zastosowanie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-872">The post was written for the first version of Entity Framework, but the steps still apply.</span></span>

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a><span data-ttu-id="4db1f-873">7,4 zagadnienia dotyczące wydajności związane z kontrolą źródła danych jednostki</span><span class="sxs-lookup"><span data-stu-id="4db1f-873">7.4       Performance considerations with the Entity Data Source Control</span></span>

<span data-ttu-id="4db1f-874">Widzimy przypadki w przypadku wielowątkowych testów wydajnościowych i obciążeniowych, w których wydajność aplikacji sieci Web przy użyciu formantu EntityDataSource pogorszy się.</span><span class="sxs-lookup"><span data-stu-id="4db1f-874">We've seen cases in multi-threaded performance and stress tests where the performance of a web application using the EntityDataSource Control deteriorates significantly.</span></span> <span data-ttu-id="4db1f-875">Podstawową przyczyną jest to, że obiekt EntityDataSource wielokrotnie wywołuje obiekt MetadataWorkspace. LoadFromAssembly na zestawach, do których odwołuje się aplikacja sieci Web, aby odnaleźć typy, które mają być używane jako jednostki.</span><span class="sxs-lookup"><span data-stu-id="4db1f-875">The underlying cause is that the EntityDataSource repeatedly calls MetadataWorkspace.LoadFromAssembly on the assemblies referenced by the Web application to discover the types to be used as entities.</span></span>

<span data-ttu-id="4db1f-876">Rozwiązaniem jest ustawienie ContextTypeName obiektu EntityDataSource do nazwy typu klasy pochodnej ObjectContext.</span><span class="sxs-lookup"><span data-stu-id="4db1f-876">The solution is to set the ContextTypeName of the EntityDataSource to the type name of your derived ObjectContext class.</span></span> <span data-ttu-id="4db1f-877">Powoduje to wyłączenie mechanizmu, który skanuje wszystkie przywoływane zestawy dla typów jednostek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-877">This turns off the mechanism that scans all referenced assemblies for entity types.</span></span>

<span data-ttu-id="4db1f-878">Ustawienie pola ContextTypeName uniemożliwia również wystąpienie problemu funkcjonalnego, w którym obiekt EntityDataSource w programie .NET 4,0 zgłasza ReflectionTypeLoadException, gdy nie może załadować typu z zestawu za pomocą odbicia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-878">Setting the ContextTypeName field also prevents a functional problem where the EntityDataSource in .NET 4.0 throws a ReflectionTypeLoadException when it can't load a type from an assembly via reflection.</span></span> <span data-ttu-id="4db1f-879">Ten problem został rozwiązany w programie .NET 4,5.</span><span class="sxs-lookup"><span data-stu-id="4db1f-879">This issue has been fixed in .NET 4.5.</span></span>

### <a name="75-poco-entities-and-change-tracking-proxies"></a><span data-ttu-id="4db1f-880">7,5 jednostek POCO i serwerów proxy śledzenia zmian</span><span class="sxs-lookup"><span data-stu-id="4db1f-880">7.5       POCO entities and change tracking proxies</span></span>

<span data-ttu-id="4db1f-881">Entity Framework umożliwia korzystanie z niestandardowych klas danych razem z modelem danych bez wprowadzania jakichkolwiek modyfikacji klas danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-881">Entity Framework enables you to use custom data classes together with your data model without making any modifications to the data classes themselves.</span></span> <span data-ttu-id="4db1f-882">Oznacza to, że można użyć "zwykłych" obiektów CLR (POCO), takich jak istniejące obiekty domeny, z modelem danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-882">This means that you can use "plain-old" CLR objects (POCO), such as existing domain objects, with your data model.</span></span> <span data-ttu-id="4db1f-883">Te klasy danych POCO (nazywane również obiektami trwałości-ignorujących), które są mapowane na jednostki, które są zdefiniowane w modelu danych, obsługują większość tych samych zachowań zapytania, INSERT, Update i DELETE jako typy jednostek, które są generowane przez narzędzia Entity Data Model.</span><span class="sxs-lookup"><span data-stu-id="4db1f-883">These POCO data classes (also known as persistence-ignorant objects), which are mapped to entities that are defined in a data model, support most of the same query, insert, update, and delete behaviors as entity types that are generated by the Entity Data Model tools.</span></span>

<span data-ttu-id="4db1f-884">Entity Framework może również tworzyć klasy proxy pochodzące z typów POCO, które są używane do włączania funkcji, takich jak ładowanie z opóźnieniem i automatyczne śledzenie zmian w jednostkach POCO.</span><span class="sxs-lookup"><span data-stu-id="4db1f-884">Entity Framework can also create proxy classes derived from your POCO types, which are used when you want to enable features such as lazy loading and automatic change tracking on POCO entities.</span></span> <span data-ttu-id="4db1f-885">Twoich zajęciach POCO muszą spełniać określone wymagania, aby umożliwić Entity Framework użyć serwerów proxy, zgodnie z opisem w tym miejscu: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span><span class="sxs-lookup"><span data-stu-id="4db1f-885">Your POCO classes must meet certain requirements to allow Entity Framework to use proxies, as described here: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span></span>

<span data-ttu-id="4db1f-886">Serwery proxy śledzenia szansy powiadomień będą powiadamiać menedżera stanu obiektów za każdym razem, gdy jego wartość zostanie zmieniona, więc Entity Framework wie o rzeczywistym stanie jednostek przez cały czas.</span><span class="sxs-lookup"><span data-stu-id="4db1f-886">Chance tracking proxies will notify the object state manager each time any of the properties of your entities has its value changed, so Entity Framework knows the actual state of your entities all the time.</span></span> <span data-ttu-id="4db1f-887">Jest to realizowane przez dodanie zdarzeń powiadomień do treści metod metody ustawiającej właściwości i posiadanie przetwarzania takich zdarzeń przez menedżera stanu obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-887">This is done by adding notification events to the body of the setter methods of your properties, and having the object state manager processing such events.</span></span> <span data-ttu-id="4db1f-888">Należy pamiętać, że utworzenie jednostki proxy będzie zazwyczaj droższe niż utworzenie jednostki POCO innej niż proxy z powodu dodanego zestawu zdarzeń utworzonych przez Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-888">Note that creating a proxy entity will typically be more expensive than creating a non-proxy POCO entity due to the added set of events created by Entity Framework.</span></span>

<span data-ttu-id="4db1f-889">Gdy jednostka POCO nie ma serwera proxy śledzenia zmian, można znaleźć zmiany, porównując zawartość jednostek z kopią poprzedniego zapisanego stanu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-889">When a POCO entity does not have a change tracking proxy, changes are found by comparing the contents of your entities against a copy of a previous saved state.</span></span> <span data-ttu-id="4db1f-890">To głębokie porównanie będzie długotrwałym procesem, gdy istnieje wiele jednostek w Twoim kontekście lub gdy jednostki mają bardzo dużą ilość właściwości, nawet jeśli żadna z nich nie zmieniła się od czasu ostatniego porównania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-890">This deep comparison will become a lengthy process when you have many entities in your context, or when your entities have a very large amount of properties, even if none of them changed since the last comparison took place.</span></span>

<span data-ttu-id="4db1f-891">Podsumowanie: podczas tworzenia serwera proxy śledzenia zmian zostanie wypłacona wydajność, ale śledzenie zmian pomoże przyspieszyć proces wykrywania zmian, gdy jednostki będą mieć wiele właściwości lub jeśli w modelu istnieje wiele jednostek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-891">In summary: you’ll pay a performance hit when creating the change tracking proxy, but change tracking will help you speed up the change detection process when your entities have many properties or when you have many entities in your model.</span></span> <span data-ttu-id="4db1f-892">W przypadku jednostek z małą liczbą właściwości, w których ilość jednostek nie rośnie zbyt wiele, posiadanie serwerów proxy śledzenia zmian może nie być dużo korzystne.</span><span class="sxs-lookup"><span data-stu-id="4db1f-892">For entities with a small number of properties where the amount of entities doesn’t grow too much, having change tracking proxies may not be of much benefit.</span></span>

## <a name="8-loading-related-entities"></a><span data-ttu-id="4db1f-893">8\. ładowanie powiązanych jednostek</span><span class="sxs-lookup"><span data-stu-id="4db1f-893">8 Loading Related Entities</span></span>

### <a name="81-lazy-loading-vs-eager-loading"></a><span data-ttu-id="4db1f-894">8,1 ładowania z opóźnieniem a Ładowanie eager</span><span class="sxs-lookup"><span data-stu-id="4db1f-894">8.1 Lazy Loading vs. Eager Loading</span></span>

<span data-ttu-id="4db1f-895">Entity Framework oferuje kilka różnych sposobów ładowania jednostek, które są powiązane z jednostką docelową.</span><span class="sxs-lookup"><span data-stu-id="4db1f-895">Entity Framework offers several different ways to load the entities that are related to your target entity.</span></span> <span data-ttu-id="4db1f-896">Na przykład podczas wykonywania zapytania dotyczącego produktów istnieją różne sposoby ładowania powiązanych zamówień do menedżera stanu obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-896">For example, when you query for Products, there are different ways that the related Orders will be loaded into the Object State Manager.</span></span> <span data-ttu-id="4db1f-897">Z punktu widzenia wydajności największe pytanie, które należy wziąć pod uwagę podczas ładowania powiązanych jednostek, będzie używać ładowania z opóźnieniem lub ładowania eager.</span><span class="sxs-lookup"><span data-stu-id="4db1f-897">From a performance standpoint, the biggest question to consider when loading related entities will be whether to use Lazy Loading or Eager Loading.</span></span>

<span data-ttu-id="4db1f-898">Podczas ładowania eager powiązane jednostki są ładowane wraz z zestawem jednostek docelowych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-898">When using Eager Loading, the related entities are loaded along with your target entity set.</span></span> <span data-ttu-id="4db1f-899">Używasz instrukcji include w zapytaniu, aby wskazać, które powiązane jednostki mają zostać umieszczone.</span><span class="sxs-lookup"><span data-stu-id="4db1f-899">You use an Include statement in your query to indicate which related entities you want to bring in.</span></span>

<span data-ttu-id="4db1f-900">W przypadku używania ładowania z opóźnieniem początkowe zapytanie jest tylko w docelowym zestawie jednostek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-900">When using Lazy Loading, your initial query only brings in the target entity set.</span></span> <span data-ttu-id="4db1f-901">Jednak za każdym razem, gdy uzyskujesz dostęp do właściwości nawigacji, w sklepie zostanie wystawione inne zapytanie w celu załadowania jednostki powiązanej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-901">But whenever you access a navigation property, another query is issued against the store to load the related entity.</span></span>

<span data-ttu-id="4db1f-902">Po załadowaniu jednostki wszelkie dalsze zapytania dotyczące jednostki będą ładować je bezpośrednio z menedżera stanu obiektów, niezależnie od tego, czy używasz ładowania z opóźnieniem, czy ładowania eager.</span><span class="sxs-lookup"><span data-stu-id="4db1f-902">Once an entity has been loaded, any further queries for the entity will load it directly from the Object State Manager, whether you are using lazy loading or eager loading.</span></span>

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a><span data-ttu-id="4db1f-903">8,2 jak wybrać między ładowaniem z opóźnieniem i ładowaniem eager</span><span class="sxs-lookup"><span data-stu-id="4db1f-903">8.2 How to choose between Lazy Loading and Eager Loading</span></span>

<span data-ttu-id="4db1f-904">Ważne jest, aby zrozumieć różnicę między ładowaniem z opóźnieniem i ładowaniem eager, dzięki czemu można wybrać właściwy wybór dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-904">The important thing is that you understand the difference between Lazy Loading and Eager Loading so that you can make the correct choice for your application.</span></span> <span data-ttu-id="4db1f-905">Pomoże to w ocenie kompromisu między wieloma żądaniami w bazie danych a pojedynczym żądaniem, które może zawierać duży ładunek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-905">This will help you evaluate the tradeoff between multiple requests against the database versus a single request that may contain a large payload.</span></span> <span data-ttu-id="4db1f-906">Może być konieczne użycie eager ładowania w niektórych częściach aplikacji i załadowanie z opóźnieniem w innych częściach.</span><span class="sxs-lookup"><span data-stu-id="4db1f-906">It may be appropriate to use eager loading in some parts of your application and lazy loading in other parts.</span></span>

<span data-ttu-id="4db1f-907">Przykładem tego, co dzieje się na wystawie, Załóżmy, że chcesz wysyłać zapytania dotyczące klientów, którzy mieszkają w Wielkiej Brytanii i ich liczbie zamówień.</span><span class="sxs-lookup"><span data-stu-id="4db1f-907">As an example of what's happening under the hood, suppose you want to query for the customers who live in the UK and their order count.</span></span>

<span data-ttu-id="4db1f-908">**Używanie ładowania eager**</span><span class="sxs-lookup"><span data-stu-id="4db1f-908">**Using Eager Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="4db1f-909">**Używanie ładowania z opóźnieniem**</span><span class="sxs-lookup"><span data-stu-id="4db1f-909">**Using Lazy Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="4db1f-910">Podczas ładowania eager należy wydać pojedyncze zapytanie zwracające wszystkich klientów i wszystkie zamówienia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-910">When using eager loading, you'll issue a single query that returns all customers and all orders.</span></span> <span data-ttu-id="4db1f-911">Polecenie Store wygląda następująco:</span><span class="sxs-lookup"><span data-stu-id="4db1f-911">The store command looks like:</span></span>

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

<span data-ttu-id="4db1f-912">W przypadku korzystania z ładowania z opóźnieniem należy początkowo wydać następujące zapytanie:</span><span class="sxs-lookup"><span data-stu-id="4db1f-912">When using lazy loading, you'll issue the following query initially:</span></span>

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

<span data-ttu-id="4db1f-913">Za każdym razem, gdy użytkownik uzyskuje dostęp do właściwości nawigacji Orders klienta, w sklepie zostanie wystawione inne zapytanie, takie jak następujące:</span><span class="sxs-lookup"><span data-stu-id="4db1f-913">And each time you access the Orders navigation property of a customer another query like the following is issued against the store:</span></span>

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

<span data-ttu-id="4db1f-914">Aby uzyskać więcej informacji, zobacz [ładowanie powiązanych obiektów](https://msdn.microsoft.com/library/bb896272.aspx).</span><span class="sxs-lookup"><span data-stu-id="4db1f-914">For more information, see the [Loading Related Objects](https://msdn.microsoft.com/library/bb896272.aspx).</span></span>

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a><span data-ttu-id="4db1f-915">8.2.1 ładowanie z opóźnieniem a eager ładowanie Ściągawka arkusza</span><span class="sxs-lookup"><span data-stu-id="4db1f-915">8.2.1 Lazy Loading versus Eager Loading cheat sheet</span></span>

<span data-ttu-id="4db1f-916">Nie ma takiego znaczenia, aby można było wybrać eager ładowanie i ładowanie z opóźnieniem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-916">There’s no such thing as a one-size-fits-all to choosing eager loading versus lazy loading.</span></span> <span data-ttu-id="4db1f-917">Spróbuj najpierw zrozumieć różnice między obiema strategiami, aby można było dobrze uzyskać świadomą decyzję; należy również rozważyć, czy kod pasuje do żadnego z następujących scenariuszy:</span><span class="sxs-lookup"><span data-stu-id="4db1f-917">Try first to understand the differences between both strategies so you can do a well informed decision; also, consider if your code fits to any of the following scenarios:</span></span>

| <span data-ttu-id="4db1f-918">Scenariusz</span><span class="sxs-lookup"><span data-stu-id="4db1f-918">Scenario</span></span>                                                                    | <span data-ttu-id="4db1f-919">Nasza sugestia</span><span class="sxs-lookup"><span data-stu-id="4db1f-919">Our Suggestion</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="4db1f-920">Czy musisz uzyskać dostęp do wielu właściwości nawigacji z pobranych jednostek?</span><span class="sxs-lookup"><span data-stu-id="4db1f-920">Do you need to access many navigation properties from the fetched entities?</span></span> | <span data-ttu-id="4db1f-921">**Nie** — obie opcje będą prawdopodobnie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-921">**No** - Both options will probably do.</span></span> <span data-ttu-id="4db1f-922">Jeśli jednak ładunek nie jest zbyt duży, mogą wystąpić korzyści z wydajności przy użyciu ładowania eager, ponieważ wymaga to mniejszej liczby podróży sieciowych w celu zmaterializowania obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-922">However, if the payload your query is bringing is not too big, you may experience performance benefits by using Eager loading as it’ll require less network round trips to materialize your objects.</span></span> <br/> <br/> <span data-ttu-id="4db1f-923">**Tak** — Jeśli chcesz uzyskać dostęp do wielu właściwości nawigacji z jednostek, możesz to zrobić za pomocą wielu instrukcji include w zapytaniu z eager ładowaniem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-923">**Yes** -  If you need to access many navigation properties from the entities, you’d do that by using multiple include statements in your query with Eager loading.</span></span> <span data-ttu-id="4db1f-924">Im więcej jednostek zostanie uwzględnionych, tym większy ładunek zostanie zwrócony przez zapytanie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-924">The more entities you include, the bigger the payload your query will return.</span></span> <span data-ttu-id="4db1f-925">Po dołączeniu trzech lub większej liczby jednostek do zapytania Rozważ przełączenie na ładowanie z opóźnieniem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-925">Once you include three or more entities into your query, consider switching to Lazy loading.</span></span> |
| <span data-ttu-id="4db1f-926">Czy wiesz dokładnie, jakie dane będą potrzebne w czasie wykonywania?</span><span class="sxs-lookup"><span data-stu-id="4db1f-926">Do you know exactly what data will be needed at run time?</span></span>                   | <span data-ttu-id="4db1f-927">Pobieranie z opóźnieniem będzie lepszym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-927">**No** - Lazy loading will be better for you.</span></span> <span data-ttu-id="4db1f-928">W przeciwnym razie możesz zakończyć wykonywanie zapytań dotyczących danych, które nie są potrzebne.</span><span class="sxs-lookup"><span data-stu-id="4db1f-928">Otherwise, you may end up querying for data that you will not need.</span></span> <br/> <br/> <span data-ttu-id="4db1f-929">**Tak** — ładowanie eager jest prawdopodobnie najlepszym trafieniem; ułatwi to szybsze ładowanie całych zestawów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-929">**Yes** - Eager loading is probably your best bet; it will help loading entire sets faster.</span></span> <span data-ttu-id="4db1f-930">Jeśli zapytanie wymaga pobrania bardzo dużej ilości danych i będzie zbyt wolne, spróbuj wykonać ładowanie z opóźnieniem.</span><span class="sxs-lookup"><span data-stu-id="4db1f-930">If your query requires fetching a very large amount of data, and this becomes too slow, then try Lazy loading instead.</span></span>                                                                                                                                                                                                                                                       |
| <span data-ttu-id="4db1f-931">Czy kod wykonywany jest daleko od bazy danych?</span><span class="sxs-lookup"><span data-stu-id="4db1f-931">Is your code executing far from your database?</span></span> <span data-ttu-id="4db1f-932">(zwiększone opóźnienie sieci)</span><span class="sxs-lookup"><span data-stu-id="4db1f-932">(increased network latency)</span></span>  | <span data-ttu-id="4db1f-933">**Nie** — gdy opóźnienie sieci nie jest problemem, użycie ładowania z opóźnieniem może uprościć kod.</span><span class="sxs-lookup"><span data-stu-id="4db1f-933">**No** - When the network latency is not an issue, using Lazy loading may simplify your code.</span></span> <span data-ttu-id="4db1f-934">Należy pamiętać, że topologia aplikacji może się zmieniać, dlatego nie należy podejmować żadnych bliskości bazy danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-934">Remember that the topology of your application may change, so don’t take database proximity for granted.</span></span> <br/> <br/> <span data-ttu-id="4db1f-935">**Tak** — w przypadku problemu z siecią możesz zdecydować, co lepiej pasuje do danego scenariusza.</span><span class="sxs-lookup"><span data-stu-id="4db1f-935">**Yes** - When the network is a problem, only you can decide what fits better for your scenario.</span></span> <span data-ttu-id="4db1f-936">Zwykle ładowanie eager będzie lepszym rozwiązaniem, ponieważ wymaga mniejszej liczby rejsów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-936">Typically Eager loading will be better because it requires fewer round trips.</span></span>                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a><span data-ttu-id="4db1f-937">8.2.2 problemy z wydajnością wielu obejmuje</span><span class="sxs-lookup"><span data-stu-id="4db1f-937">8.2.2       Performance concerns with multiple Includes</span></span>

<span data-ttu-id="4db1f-938">Gdy będziemy słyszeć pytania dotyczące wydajności, które obejmują problemy związane z czasem odpowiedzi serwera, źródłem problemu często są zapytania z wieloma instrukcjami INCLUDE.</span><span class="sxs-lookup"><span data-stu-id="4db1f-938">When we hear performance questions that involve server response time problems, the source of the issue is frequently queries with multiple Include statements.</span></span> <span data-ttu-id="4db1f-939">Chociaż w tym obiekty pokrewne w zapytaniu są zaawansowane, ważne jest, aby zrozumieć, co się dzieje w ramach okładek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-939">While including related entities in a query is powerful, it's important to understand what's happening under the covers.</span></span>

<span data-ttu-id="4db1f-940">Wykonywanie zapytania z wieloma instrukcjami include w tym czasie zajmuje stosunkowo dużo czasu, aby przejść przez nasz kompilator wewnętrznego planu, aby utworzyć polecenie magazynu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-940">It takes a relatively long time for a query with multiple Include statements in it to go through our internal plan compiler to produce the store command.</span></span> <span data-ttu-id="4db1f-941">Większość tego czasu poświęca próbę optymalizacji wyniku zapytania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-941">The majority of this time is spent trying to optimize the resulting query.</span></span> <span data-ttu-id="4db1f-942">Polecenie wygenerowany magazyn będzie zawierać sprzężenie zewnętrzne lub Unię dla każdej z nich, w zależności od mapowania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-942">The generated store command will contain an Outer Join or Union for each Include, depending on your mapping.</span></span> <span data-ttu-id="4db1f-943">Takie zapytania spowodują, że w ramach jednego ładunku są nawiązane duże połączone wykresy, które będą acerbate wszelkie problemy z przepustowością, zwłaszcza gdy istnieje wiele nadmiarowości w ładunku (na przykład gdy na przechodzenie jest używanych wielu poziomów dołączania) skojarzenia w kierunku "jeden do wielu").</span><span class="sxs-lookup"><span data-stu-id="4db1f-943">Queries like this will bring in large connected graphs from your database in a single payload, which will acerbate any bandwidth issues, especially when there is a lot of redundancy in the payload (for example, when multiple levels of Include are used to traverse associations in the one-to-many direction).</span></span>

<span data-ttu-id="4db1f-944">Można sprawdzić przypadki, w których zapytania zwracają nadmiernie duże ładunki, uzyskując dostęp do bazowego TSQL zapytania przy użyciu ToTraceString i wykonując polecenie Store w SQL Server Management Studio, aby zobaczyć rozmiar ładunku.</span><span class="sxs-lookup"><span data-stu-id="4db1f-944">You can check for cases where your queries are returning excessively large payloads by accessing the underlying TSQL for the query by using ToTraceString and executing the store command in SQL Server Management Studio to see the payload size.</span></span> <span data-ttu-id="4db1f-945">W takich przypadkach można spróbować zmniejszyć liczbę instrukcji include w zapytaniu, aby po prostu wprowadzić potrzebne dane.</span><span class="sxs-lookup"><span data-stu-id="4db1f-945">In such cases you can try to reduce the number of Include statements in your query to just bring in the data you need.</span></span> <span data-ttu-id="4db1f-946">Lub może być możliwe przerwanie zapytania w krótszej sekwencji podzapytań, na przykład:</span><span class="sxs-lookup"><span data-stu-id="4db1f-946">Or you may be able to break your query into a smaller sequence of subqueries, for example:</span></span>

<span data-ttu-id="4db1f-947">**Przed usunięciem zapytania:**</span><span class="sxs-lookup"><span data-stu-id="4db1f-947">**Before breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="4db1f-948">**Po przeprowadzeniu przerwania zapytania:**</span><span class="sxs-lookup"><span data-stu-id="4db1f-948">**After breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="4db1f-949">Ta funkcja będzie działać tylko na śledzonych zapytaniach, ponieważ korzystamy z możliwości automatycznego wykonywania rozpoznawania tożsamości i naprawiania skojarzenia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-949">This will work only on tracked queries, as we are making use of the ability the context has to perform identity resolution and association fixup automatically.</span></span>

<span data-ttu-id="4db1f-950">Podobnie jak w przypadku ładowania z opóźnieniem, kompromis będzie więcej zapytań dla mniejszych ładunków.</span><span class="sxs-lookup"><span data-stu-id="4db1f-950">As with lazy loading, the tradeoff will be more queries for smaller payloads.</span></span> <span data-ttu-id="4db1f-951">Można również użyć projekcji poszczególnych właściwości, aby jawnie wybierać tylko potrzebne dane z poszczególnych jednostek, ale nie będzie można ładować jednostek w tym przypadku, a aktualizacje nie będą obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="4db1f-951">You can also use projections of individual properties to explicitly select only the data you need from each entity, but you will not be loading entities in this case, and updates will not be supported.</span></span>

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a><span data-ttu-id="4db1f-952">8.2.3 obejście, aby uzyskać pobieranie z opóźnieniem właściwości</span><span class="sxs-lookup"><span data-stu-id="4db1f-952">8.2.3 Workaround to get lazy loading of properties</span></span>

<span data-ttu-id="4db1f-953">Entity Framework obecnie nie obsługuje ładowania z opóźnieniem właściwości skalarnych lub złożonych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-953">Entity Framework currently doesn’t support lazy loading of scalar or complex properties.</span></span> <span data-ttu-id="4db1f-954">Jednak w przypadkach, gdy istnieje tabela zawierająca duży obiekt, taki jak obiekt BLOB, można użyć podziału tabeli, aby oddzielić duże właściwości do osobnej jednostki.</span><span class="sxs-lookup"><span data-stu-id="4db1f-954">However, in cases where you have a table that includes a large object such as a BLOB, you can use table splitting to separate the large properties into a separate entity.</span></span> <span data-ttu-id="4db1f-955">Załóżmy na przykład, że masz tabelę produktów, która zawiera kolumnę zdjęć varbinary.</span><span class="sxs-lookup"><span data-stu-id="4db1f-955">For example, suppose you have a Product table that includes a varbinary photo column.</span></span> <span data-ttu-id="4db1f-956">Jeśli nie ma często potrzeby uzyskiwania dostępu do tej właściwości w zapytaniach, można użyć podziału tabeli, aby przenieść tylko te części jednostki, która jest zwykle potrzebna.</span><span class="sxs-lookup"><span data-stu-id="4db1f-956">If you don't frequently need to access this property in your queries, you can use table splitting to bring in only the parts of the entity that you normally need.</span></span> <span data-ttu-id="4db1f-957">Jednostka reprezentująca zdjęcie produktu zostanie załadowana tylko wtedy, gdy jest to konieczne.</span><span class="sxs-lookup"><span data-stu-id="4db1f-957">The entity representing the product photo will only be loaded when you explicitly need it.</span></span>

<span data-ttu-id="4db1f-958">Dobre zasób, który pokazuje, jak włączyć dzielenia tabeli jest "Tabela podział w programie Entity Framework" Gil Fink wpis w blogu: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-958">A good resource that shows how to enable table splitting is Gil Fink's "Table Splitting in Entity Framework" blog post: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span></span>

## <a name="9-other-considerations"></a><span data-ttu-id="4db1f-959">9 inne zagadnienia</span><span class="sxs-lookup"><span data-stu-id="4db1f-959">9 Other considerations</span></span>

### <a name="91-server-garbage-collection"></a><span data-ttu-id="4db1f-960">Odzyskiwanie pamięci serwera 9,1</span><span class="sxs-lookup"><span data-stu-id="4db1f-960">9.1      Server Garbage Collection</span></span>

<span data-ttu-id="4db1f-961">Niektórzy użytkownicy mogą napotkać rywalizacje o zasoby, które ograniczają równoległość, której oczekuje, gdy moduł wyrzucania elementów bezużytecznych nie jest prawidłowo skonfigurowany.</span><span class="sxs-lookup"><span data-stu-id="4db1f-961">Some users might experience resource contention that limits the parallelism they are expecting when the Garbage Collector is not properly configured.</span></span> <span data-ttu-id="4db1f-962">Za każdym razem, gdy program EF jest używany w scenariuszu wielowątkowym lub w dowolnej aplikacji, która jest podobna do systemu po stronie serwera, upewnij się, że włączono odzyskiwanie pamięci serwera.</span><span class="sxs-lookup"><span data-stu-id="4db1f-962">Whenever EF is used in a multithreaded scenario, or in any application that resembles a server-side system, make sure to enable Server Garbage Collection.</span></span> <span data-ttu-id="4db1f-963">Jest to realizowane za pomocą prostego ustawienia w pliku konfiguracyjnym aplikacji:</span><span class="sxs-lookup"><span data-stu-id="4db1f-963">This is done via a simple setting in your application config file:</span></span>

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

<span data-ttu-id="4db1f-964">Powinno to zmniejszyć rywalizację o wątki i zwiększyć przepływność nawet o 30% w scenariuszach zapełnionych przez procesor CPU.</span><span class="sxs-lookup"><span data-stu-id="4db1f-964">This should decrease your thread contention and increase your throughput by up to 30% in CPU saturated scenarios.</span></span> <span data-ttu-id="4db1f-965">Ogólnie rzecz biorąc, należy zawsze testować sposób działania aplikacji przy użyciu klasycznego wyrzucania elementów bezużytecznych (który jest lepiej dostosowany do scenariuszy interfejsu użytkownika i klienta), a także do wyrzucania elementów bezużytecznych serwera.</span><span class="sxs-lookup"><span data-stu-id="4db1f-965">In general terms, you should always test how your application behaves using the classic Garbage Collection (which is better tuned for UI and client side scenarios) as well as the Server Garbage Collection.</span></span>

### <a name="92-autodetectchanges"></a><span data-ttu-id="4db1f-966">9,2 AutoDetectChanges</span><span class="sxs-lookup"><span data-stu-id="4db1f-966">9.2      AutoDetectChanges</span></span>

<span data-ttu-id="4db1f-967">Jak wspomniano wcześniej, Entity Framework mogą pokazać problemy z wydajnością, gdy pamięć podręczna obiektów ma wiele jednostek.</span><span class="sxs-lookup"><span data-stu-id="4db1f-967">As mentioned earlier, Entity Framework might show performance issues when the object cache has many entities.</span></span> <span data-ttu-id="4db1f-968">Niektóre operacje, takie jak dodawanie, usuwanie, Znajdowanie, wprowadzanie i metody SaveChanges, wyzwalają wywołania do DetectChanges, które mogą zużywać dużą ilość czasu procesora w zależności od rozmiaru pamięci podręcznej obiektów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-968">Certain operations, such as Add, Remove, Find, Entry and SaveChanges, trigger calls to DetectChanges which might consume a large amount of CPU based on how large the object cache has become.</span></span> <span data-ttu-id="4db1f-969">Przyczyną takiego działania jest fakt, że pamięć podręczna obiektów i Menedżer stanu obiektów próbują zachować się jak najszybciej w przypadku każdej operacji wykonywanej do kontekstu, aby wygenerowane dane były poprawne w ramach szerokiej gamy scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="4db1f-969">The reason for this is that the object cache and the object state manager try to stay as synchronized as possible on each operation performed to a context so that the produced data is guaranteed to be correct under a wide array of scenarios.</span></span>

<span data-ttu-id="4db1f-970">Ogólnie rzecz biorąc, dobrym sposobem jest pozostawienie Entity Framework automatycznego wykrywania zmian w całym cyklu życia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-970">It is generally a good practice to leave Entity Framework’s automatic change detection enabled for the entire life of your application.</span></span> <span data-ttu-id="4db1f-971">Jeśli Twój Scenariusz ma negatywny wpływ na duże użycie procesora CPU, a Twoje profile wskazują, że przyczyna jest wywołaniem DetectChanges, rozważ tymczasowe wyłączenie AutoDetectChanges w poufnej części kodu:</span><span class="sxs-lookup"><span data-stu-id="4db1f-971">If your scenario is being negatively affected by high CPU usage and your profiles indicate that the culprit is the call to DetectChanges, consider temporarily turning off AutoDetectChanges in the sensitive portion of your code:</span></span>

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

<span data-ttu-id="4db1f-972">Przed wyłączeniem AutoDetectChanges warto zrozumieć, że może to spowodować utratę możliwości śledzenia pewnych informacji o zmianach wprowadzonych w jednostkach przez Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-972">Before turning off AutoDetectChanges, it’s good to understand that this might cause Entity Framework to lose its ability to track certain information about the changes that are taking place on the entities.</span></span> <span data-ttu-id="4db1f-973">Jeśli są obsługiwane nieprawidłowo, może to spowodować niespójność danych w aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-973">If handled incorrectly, this might cause data inconsistency on your application.</span></span> <span data-ttu-id="4db1f-974">Aby uzyskać więcej informacji na temat wyłączania AutoDetectChanges, przeczytaj \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-974">For more information on turning off AutoDetectChanges, read \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span></span>

### <a name="93-context-per-request"></a><span data-ttu-id="4db1f-975">kontekst 9,3 na żądanie</span><span class="sxs-lookup"><span data-stu-id="4db1f-975">9.3      Context per request</span></span>

<span data-ttu-id="4db1f-976">Konteksty Entity Framework są przeznaczone do użycia jako wystąpienia krótkoterminowe w celu zapewnienia optymalnej wydajności.</span><span class="sxs-lookup"><span data-stu-id="4db1f-976">Entity Framework’s contexts are meant to be used as short-lived instances in order to provide the most optimal performance experience.</span></span> <span data-ttu-id="4db1f-977">Należy oczekiwać, że konteksty są krótkie i odrzucane, a jako takie zostały zaimplementowane jako bardzo lekkie i w miarę możliwości wykorzystują metadane.</span><span class="sxs-lookup"><span data-stu-id="4db1f-977">Contexts are expected to be short lived and discarded, and as such have been implemented to be very lightweight and reutilize metadata whenever possible.</span></span> <span data-ttu-id="4db1f-978">W scenariuszach sieci Web ważne jest, aby mieć to na uwadze i nie mieć kontekstu dłużej niż czas trwania pojedynczego żądania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-978">In web scenarios it’s important to keep this in mind and not have a context for more than the duration of a single request.</span></span> <span data-ttu-id="4db1f-979">Podobnie w przypadku scenariuszy innych niż sieci Web kontekst powinien zostać odrzucony w oparciu o zrozumienie różnych poziomów buforowania w Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-979">Similarly, in non-web scenarios, context should be discarded based on your understanding of the different levels of caching in the Entity Framework.</span></span> <span data-ttu-id="4db1f-980">Ogólnie mówiąc, jeden z nich powinien unikać wystąpienia kontekstu w całym cyklu życia aplikacji, a także kontekstów dla wątków i kontekstów statycznych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-980">Generally speaking, one should avoid having a context instance throughout the life of the application, as well as contexts per thread and static contexts.</span></span>

### <a name="94-database-null-semantics"></a><span data-ttu-id="4db1f-981">Semantyka null bazy danych 9,4</span><span class="sxs-lookup"><span data-stu-id="4db1f-981">9.4      Database null semantics</span></span>

<span data-ttu-id="4db1f-982">Entity Framework domyślnie generuje kod SQL, który ma semantykę porównania C @ no__t-0 o wartości null.</span><span class="sxs-lookup"><span data-stu-id="4db1f-982">Entity Framework by default will generate SQL code that has C\# null comparison semantics.</span></span> <span data-ttu-id="4db1f-983">Rozważmy następujące przykładowe zapytanie:</span><span class="sxs-lookup"><span data-stu-id="4db1f-983">Consider the following example query:</span></span>

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

<span data-ttu-id="4db1f-984">W tym przykładzie porównamy wiele zmiennych wartości null z właściwościami dopuszczanymi do wartości null w jednostce, takich jak IDDostawcy i CenaJednostkowa.</span><span class="sxs-lookup"><span data-stu-id="4db1f-984">In this example, we’re comparing a number of nullable variables against nullable properties on the entity, such as SupplierID and UnitPrice.</span></span> <span data-ttu-id="4db1f-985">Wygenerowane dane SQL dla tego zapytania spowodują, że wartość parametru jest taka sama jak wartość kolumny, lub jeśli oba parametry i kolumny mają wartość null.</span><span class="sxs-lookup"><span data-stu-id="4db1f-985">The generated SQL for this query will ask if the parameter value is the same as the column value, or if both the parameter and the column values are null.</span></span> <span data-ttu-id="4db1f-986">Spowoduje to ukrycie sposobu, w jaki serwer bazy danych obsługuje wartości null i zapewni spójne środowisko C @ no__t-0 null dla różnych dostawców baz danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-986">This will hide the way the database server handles nulls and will provide a consistent C\# null experience across different database vendors.</span></span> <span data-ttu-id="4db1f-987">Z drugiej strony wygenerowany kod jest bitowym zawiłe i może nie działać prawidłowo, gdy ilość porównań w instrukcji WHERE zapytania rośnie do dużej liczby.</span><span class="sxs-lookup"><span data-stu-id="4db1f-987">On the other hand, the generated code is a bit convoluted and may not perform well when the amount of comparisons in the where statement of the query grows to a large number.</span></span>

<span data-ttu-id="4db1f-988">Jednym ze sposobów postępowania z tą sytuacją jest użycie semantyki bazy danych o wartości null.</span><span class="sxs-lookup"><span data-stu-id="4db1f-988">One way to deal with this situation is by using database null semantics.</span></span> <span data-ttu-id="4db1f-989">Należy zauważyć, że może to być nieznacznie zachowywać się inaczej w przypadku semantyki o wartości null @ no__t-0, ponieważ teraz Entity Framework generuje prostszy kod SQL, który uwidacznia sposób, w jaki aparat bazy danych będzie obsługiwał wartości null.</span><span class="sxs-lookup"><span data-stu-id="4db1f-989">Note that this might potentially behave differently to the C\# null semantics since now Entity Framework will generate simpler SQL that exposes the way the database engine handles null values.</span></span> <span data-ttu-id="4db1f-990">Semantyki o wartości null bazy danych można aktywować dla kontekstu z jednym wierszem konfiguracji z konfiguracją kontekstu:</span><span class="sxs-lookup"><span data-stu-id="4db1f-990">Database null semantics can be activated per-context with one single configuration line against the context configuration:</span></span>

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

<span data-ttu-id="4db1f-991">W przypadku zapytań o małe i średnie rozmiary nie będą wyświetlane zauważalne ulepszenia wydajności podczas korzystania z semantyki o wartości null bazy danych, ale różnica będzie bardziej zauważalna w przypadku zapytań z dużą liczbą potencjalnych porównań o wartości null.</span><span class="sxs-lookup"><span data-stu-id="4db1f-991">Small to medium sized queries will not display a perceptible performance improvement when using database null semantics, but the difference will become more noticeable on queries with a large number of potential null comparisons.</span></span>

<span data-ttu-id="4db1f-992">W przykładzie powyższego zapytania różnica wydajności była mniejsza niż 2% w przypadku mikrotestu działającego w środowisku kontrolowanym.</span><span class="sxs-lookup"><span data-stu-id="4db1f-992">In the example query above, the performance difference was less than 2% in a microbenchmark running in a controlled environment.</span></span>

### <a name="95-async"></a><span data-ttu-id="4db1f-993">9,5 Async</span><span class="sxs-lookup"><span data-stu-id="4db1f-993">9.5      Async</span></span>

<span data-ttu-id="4db1f-994">Entity Framework 6 wprowadzono obsługę operacji asynchronicznych w przypadku uruchamiania programu .NET 4,5 lub nowszego.</span><span class="sxs-lookup"><span data-stu-id="4db1f-994">Entity Framework 6 introduced support of async operations when running on .NET 4.5 or later.</span></span> <span data-ttu-id="4db1f-995">W większości przypadków aplikacje, które mają rywalizację dotyczącą we/wy, będą korzystać z funkcji asynchronicznego wykonywania zapytań i zapisywania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-995">For the most part, applications that have IO related contention will benefit the most from using asynchronous query and save operations.</span></span> <span data-ttu-id="4db1f-996">Jeśli aplikacja nie pogorszy się z rywalizacją we/wy, Użycie Async będzie w najlepszym przypadku wykonywane synchronicznie i zwracać wynik w tym samym czasie co w przypadku wywołania synchronicznego lub w najgorszym przypadku, po prostu Opóźnij wykonywanie do zadania asynchronicznego i Dodaj dodatkowe Tim e do ukończenia Twojego scenariusza.</span><span class="sxs-lookup"><span data-stu-id="4db1f-996">If your application does not suffer from IO contention, the use of async will, in the best cases, run synchronously and return the result in the same amount of time as a synchronous call, or in the worst case, simply defer execution to an asynchronous task and add extra time to the completion of your scenario.</span></span>

<span data-ttu-id="4db1f-997">Instrukcje dotyczące sposobu asynchronicznego programowania pracy, która pomoże przy wyborze rozwiązania, jeśli async poprawi wydajność aplikacji odwiedzanych przez użytkownika [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span><span class="sxs-lookup"><span data-stu-id="4db1f-997">For information on how asynchronous programming work that will help you deciding if async will improve the performance of your application visit [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span></span> <span data-ttu-id="4db1f-998">Aby uzyskać więcej informacji na temat używania operacji asynchronicznych na Entity Framework, zobacz [Async Query i Zapisz @ no__t-1.</span><span class="sxs-lookup"><span data-stu-id="4db1f-998">For more information on the use of async operations on Entity Framework, see [Async Query and Save](~/ef6/fundamentals/async.md
).</span></span>

### <a name="96-ngen"></a><span data-ttu-id="4db1f-999">9,6 NGEN</span><span class="sxs-lookup"><span data-stu-id="4db1f-999">9.6      NGEN</span></span>

<span data-ttu-id="4db1f-1000">Entity Framework 6 nie jest domyślną instalacją programu .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1000">Entity Framework 6 does not come in the default installation of .NET framework.</span></span> <span data-ttu-id="4db1f-1001">W związku z tym zestawy Entity Framework nie są domyślnie NGEN, co oznacza, że cały kod Entity Framework podlega tym samym kosztom JIT'ing, co każdy inny zestaw MSIL.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1001">As such, the Entity Framework assemblies are not NGEN’d by default which means that all the Entity Framework code is subject to the same JIT’ing costs as any other MSIL assembly.</span></span> <span data-ttu-id="4db1f-1002">Może to spowodować spadek wydajności podczas tworzenia i uruchamiania aplikacji w środowiskach produkcyjnych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1002">This might degrade the F5 experience while developing and also the cold startup of your application in the production environments.</span></span> <span data-ttu-id="4db1f-1003">Aby zmniejszyć koszty procesora CPU i pamięci JIT'ing, zaleca się, aby program NGEN Entity Framework obrazy odpowiednio do potrzeb.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1003">In order to reduce the CPU and memory costs of JIT’ing it is advisable to NGEN the Entity Framework images as appropriate.</span></span> <span data-ttu-id="4db1f-1004">Aby uzyskać więcej informacji na temat ulepszania wydajności uruchamiania Entity Framework 6 z programem NGEN, zobacz [Poprawianie wydajności uruchamiania za pomocą narzędzia NGen](~/ef6/fundamentals/performance/ngen.md).</span><span class="sxs-lookup"><span data-stu-id="4db1f-1004">For more information on how to improve the startup performance of Entity Framework 6 with NGEN, see [Improving Startup Performance with NGen](~/ef6/fundamentals/performance/ngen.md).</span></span>

### <a name="97-code-first-versus-edmx"></a><span data-ttu-id="4db1f-1005">9,7 Code First w porównaniu z EDMX</span><span class="sxs-lookup"><span data-stu-id="4db1f-1005">9.7      Code First versus EDMX</span></span>

<span data-ttu-id="4db1f-1006">Entity Framework przyczyny niezgodności między programowaniem zorientowanym na obiekt i relacyjnymi bazami danych przez posiadanie reprezentacji w pamięci modelu koncepcyjnego (obiektów), schematu magazynu (bazy danych) i mapowania między tymi.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1006">Entity Framework reasons about the impedance mismatch problem between object oriented programming and relational databases by having an in-memory representation of the conceptual model (the objects), the storage schema (the database) and a mapping between the two.</span></span> <span data-ttu-id="4db1f-1007">Te metadane są nazywane Entity Data Model lub EDM jako krótkie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1007">This metadata is called an Entity Data Model, or EDM for short.</span></span> <span data-ttu-id="4db1f-1008">Z tego modelu EDM Entity Framework będą dziedziczyć widoki w celu przeprowadzenia komunikacji między danymi z obiektów znajdujących się w pamięci a bazą danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1008">From this EDM, Entity Framework will derive the views to roundtrip data from the objects in memory to the database and back.</span></span>

<span data-ttu-id="4db1f-1009">Gdy Entity Framework jest używany z plikiem EDMX, który formalnie Określa model koncepcyjny, schemat magazynu i mapowanie, wówczas etap ładowania modelu musi sprawdzić, czy model EDM jest poprawny (na przykład upewnić się, że nie ma żadnych mapowań), a następnie Wygeneruj widoki, a następnie sprawdź poprawność widoków i przygotuj te metadane do użycia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1009">When Entity Framework is used with an EDMX file that formally specifies the conceptual model, the storage schema, and the mapping, then the model loading stage only has to validate that the EDM is correct (for example, make sure that no mappings are missing), then generate the views, then validate the views and have this metadata ready for use.</span></span> <span data-ttu-id="4db1f-1010">Tylko wtedy możliwe jest wykonanie zapytania lub zapisanie nowych danych w magazynie danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1010">Only then can a query be executed or new data be saved to the data store.</span></span>

<span data-ttu-id="4db1f-1011">Code First podejście to, w swoim serca, zaawansowanego generatora Entity Data Model.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1011">The Code First approach is, at its heart, a sophisticated Entity Data Model generator.</span></span> <span data-ttu-id="4db1f-1012">Entity Framework musi utworzyć modelu EDM z dostarczonego kodu; robi to przez analizowanie klas objętych modelem, stosowanie Konwencji i Konfigurowanie modelu za pośrednictwem interfejsu API Fluent.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1012">The Entity Framework has to produce an EDM from the provided code; it does so by analyzing the classes involved in the model, applying conventions and configuring the model via the Fluent API.</span></span> <span data-ttu-id="4db1f-1013">Po skompilowaniu modelu EDM Entity Framework zasadniczo zachowuje się tak samo, jak w projekcie znajduje się plik EDMX.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1013">After the EDM is built, the Entity Framework essentially behaves the same way as it would had an EDMX file been present in the project.</span></span> <span data-ttu-id="4db1f-1014">W ten sposób Kompilowanie modelu z Code First dodaje dodatkową złożoność, która tłumaczy na wolniejszy czas uruchamiania dla Entity Framework w porównaniu z EDMX.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1014">Thus, building the model from Code First adds extra complexity that translates into a slower startup time for the Entity Framework when compared to having an EDMX.</span></span> <span data-ttu-id="4db1f-1015">Koszt jest w pełni zależny od rozmiaru i złożoności tworzonego modelu.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1015">The cost is completely dependent on the size and complexity of the model that’s being built.</span></span>

<span data-ttu-id="4db1f-1016">W przypadku korzystania z EDMX i Code First należy pamiętać, że elastyczność wprowadzona przez Code First zwiększa koszt kompilowania modelu po raz pierwszy.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1016">When choosing to use EDMX versus Code First, it’s important to know that the flexibility introduced by Code First increases the cost of building the model for the first time.</span></span> <span data-ttu-id="4db1f-1017">Jeśli aplikacja może wytrzymać koszt tego obciążenia po raz pierwszy, zazwyczaj Code First będzie preferowanym sposobem przejścia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1017">If your application can withstand the cost of this first-time load then typically Code First will be the preferred way to go.</span></span>

## <a name="10-investigating-performance"></a><span data-ttu-id="4db1f-1018">10 badanie wydajności</span><span class="sxs-lookup"><span data-stu-id="4db1f-1018">10 Investigating Performance</span></span>

### <a name="101-using-the-visual-studio-profiler"></a><span data-ttu-id="4db1f-1019">10,1 przy użyciu profilera programu Visual Studio</span><span class="sxs-lookup"><span data-stu-id="4db1f-1019">10.1 Using the Visual Studio Profiler</span></span>

<span data-ttu-id="4db1f-1020">Jeśli masz problemy z wydajnością Entity Framework, możesz użyć profilera, takiego jak wbudowany w program Visual Studio, aby zobaczyć, gdzie Twoja aplikacja spędza swoją godzinę.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1020">If you are having performance issues with the Entity Framework, you can use a profiler like the one built into Visual Studio to see where your application is spending its time.</span></span> <span data-ttu-id="4db1f-1021">To narzędzie, firma Microsoft służącego do generowania wykresów kołowych "Eksplorowanie wydajności programu ADO.NET Entity Framework — część 1" wpis w blogu ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) ukazują, gdzie Entity Framework spędza czas podczas wykonywania kwerend ścieżce nieaktywnej i bez wyłączania zasilania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1021">This is the tool we used to generate the pie charts in the “Exploring the Performance of the ADO.NET Entity Framework - Part 1” blog post ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) that show where Entity Framework spends its time during cold and warm queries.</span></span>

<span data-ttu-id="4db1f-1022">Wpis "Entity Framework profilowania przy użyciu programu Visual Studio 2010 Profiler" został zapisany przez dane i modelowanie zespołu Doradczego ds. klienta pokazuje rzeczywisty przykład sposobu użycia profilera do zbadania problemu z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1022">The "Profiling Entity Framework using the Visual Studio 2010 Profiler" blog post written by the Data and Modeling Customer Advisory Team shows a real-world example of how they used the profiler to investigate a performance problem.</span></span><span data-ttu-id="4db1f-1023">  \<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1023">  \<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>.</span></span> <span data-ttu-id="4db1f-1024">Ten wpis został zapisany dla aplikacji systemu Windows.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1024">This post was written for a windows application.</span></span> <span data-ttu-id="4db1f-1025">Jeśli zachodzi potrzeba profilowania aplikacji sieci Web, narzędzia Windows Performance Recorder (WP) i Windows Performance Analyzer (WPA) mogą działać lepiej niż w przypadku programu Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1025">If you need to profile a web application the Windows Performance Recorder (WPR) and Windows Performance Analyzer (WPA) tools may work better than working from Visual Studio.</span></span> <span data-ttu-id="4db1f-1026">WPR i WPA są częścią zestawu narzędzi wydajności Windows, który jest dołączony do Windows Assessment and Deployment Kit ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)).</span><span class="sxs-lookup"><span data-stu-id="4db1f-1026">WPR and WPA are part of the Windows Performance Toolkit which is included with the Windows Assessment and Deployment Kit ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)).</span></span>

### <a name="102-applicationdatabase-profiling"></a><span data-ttu-id="4db1f-1027">10,2 Profilowanie aplikacji/bazy danych</span><span class="sxs-lookup"><span data-stu-id="4db1f-1027">10.2 Application/Database profiling</span></span>

<span data-ttu-id="4db1f-1028">Narzędzia, takie jak Profiler wbudowany w program Visual Studio, informują o tym, gdzie Twoja aplikacja jest w trakcie.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1028">Tools like the profiler built into Visual Studio tell you where your application is spending time.</span></span><span data-ttu-id="4db1f-1029">  Dostępny jest inny typ profilera służący do przeprowadzania dynamicznej analizy uruchomionej aplikacji w środowisku produkcyjnym lub przedprodukcyjnym w zależności od potrzeb, a także wyszukuje typowe pułapek i antywzorce dostępu do bazy danych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1029">  Another type of profiler is available that performs dynamic analysis of your running application, either in production or pre-production depending on needs, and looks for common pitfalls and anti-patterns of database access.</span></span>

<span data-ttu-id="4db1f-1030">Dwa komercyjnego profilowania są Profiler Framework jednostki ( \<http://efprof.com>) i ORMProfiler ( \<http://ormprofiler.com>).</span><span class="sxs-lookup"><span data-stu-id="4db1f-1030">Two commercially available profilers are the Entity Framework Profiler ( \<http://efprof.com>) and ORMProfiler ( \<http://ormprofiler.com>).</span></span>

<span data-ttu-id="4db1f-1031">Jeśli aplikacja jest aplikacją MVC używającą Code First, można użyć MiniProfiler StackExchange.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1031">If your application is an MVC application using Code First, you can use StackExchange's MiniProfiler.</span></span> <span data-ttu-id="4db1f-1032">Scott Hanselman opis tego narzędzia w jego blog znajduje się na: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1032">Scott Hanselman describes this tool in his blog at: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span></span>

<span data-ttu-id="4db1f-1033">Aby uzyskać więcej informacji na temat profilowania działania bazy danych aplikacji, zobacz artykuł dotyczący usługi Julie Lerman w witrynie MSDN Magazine zatytułowany [profilowanie działania bazy danych w Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span><span class="sxs-lookup"><span data-stu-id="4db1f-1033">For more information on profiling your application's database activity, see Julie Lerman's MSDN Magazine article titled [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span></span>

### <a name="103-database-logger"></a><span data-ttu-id="4db1f-1034">Rejestrator bazy danych 10,3</span><span class="sxs-lookup"><span data-stu-id="4db1f-1034">10.3 Database logger</span></span>

<span data-ttu-id="4db1f-1035">W przypadku korzystania z programu Entity Framework 6 należy również rozważyć użycie wbudowanych funkcji rejestrowania.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1035">If you are using Entity Framework 6 also consider using the built-in logging functionality.</span></span> <span data-ttu-id="4db1f-1036">Właściwość baza danych kontekstu może być zainstruuja, aby rejestrować swoje działania za pomocą prostej konfiguracji jednowierszowej:</span><span class="sxs-lookup"><span data-stu-id="4db1f-1036">The Database property of the context can be instructed to log its activity via a simple one-line configuration:</span></span>

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

<span data-ttu-id="4db1f-1037">W tym przykładzie działanie bazy danych zostanie zarejestrowane w konsoli programu, ale właściwości dziennika można skonfigurować do wywoływania akcji @ no__t-0string @ no__t-1 delegata.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1037">In this example the database activity will be logged to the console, but the Log property can be configured to call any Action&lt;string&gt; delegate.</span></span>

<span data-ttu-id="4db1f-1038">Jeśli chcesz włączyć rejestrowanie bazy danych bez ponownego kompilowania i używasz Entity Framework 6,1 lub nowszej, możesz to zrobić przez dodanie interceptora w pliku Web. config lub App. config aplikacji.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1038">If you want to enable database logging without recompiling, and you are using Entity Framework 6.1 or later, you can do so by adding an interceptor in the web.config or app.config file of your application.</span></span>

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

<span data-ttu-id="4db1f-1039">Aby uzyskać więcej informacji na temat dodawania rejestrowanie bez konieczności ponownego kompilowania przejdź do pozycji \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1039">For more information on how to add logging without recompiling go to \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span></span>

## <a name="11-appendix"></a><span data-ttu-id="4db1f-1040">11 dodatek</span><span class="sxs-lookup"><span data-stu-id="4db1f-1040">11 Appendix</span></span>

### <a name="111-a-test-environment"></a><span data-ttu-id="4db1f-1041">Środowisko testowe 11,1 A.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1041">11.1 A. Test Environment</span></span>

<span data-ttu-id="4db1f-1042">W tym środowisku jest stosowana konfiguracja 2-maszynowa z bazą danych na oddzielnym komputerze od aplikacji klienckiej.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1042">This environment uses a 2-machine setup with the database on a separate machine from the client application.</span></span> <span data-ttu-id="4db1f-1043">Maszyny znajdują się w tym samym stojaku, więc opóźnienie sieci jest stosunkowo małe, ale bardziej realistyczne niż środowisko pojedynczej maszyny.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1043">Machines are in the same rack, so network latency is relatively low, but more realistic than a single-machine environment.</span></span>

#### <a name="1111-app-server"></a><span data-ttu-id="4db1f-1044">Serwer aplikacji 11.1.1</span><span class="sxs-lookup"><span data-stu-id="4db1f-1044">11.1.1       App Server</span></span>

##### <a name="11111-software-environment"></a><span data-ttu-id="4db1f-1045">Środowisko oprogramowania 11.1.1.1</span><span class="sxs-lookup"><span data-stu-id="4db1f-1045">11.1.1.1      Software Environment</span></span>

-   <span data-ttu-id="4db1f-1046">Środowisko oprogramowania Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="4db1f-1046">Entity Framework 4 Software Environment</span></span>
    -   <span data-ttu-id="4db1f-1047">Nazwa systemu operacyjnego: Windows Server 2008 R2 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1047">OS Name: Windows Server 2008 R2 Enterprise SP1.</span></span>
    -   <span data-ttu-id="4db1f-1048">Visual Studio 2010 — wersja Ultimate.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1048">Visual Studio 2010 – Ultimate.</span></span>
    -   <span data-ttu-id="4db1f-1049">Visual Studio 2010 z dodatkiem SP1 (tylko w przypadku niektórych porównań).</span><span class="sxs-lookup"><span data-stu-id="4db1f-1049">Visual Studio 2010 SP1 (only for some comparisons).</span></span>
-   <span data-ttu-id="4db1f-1050">Entity Framework 5 i 6 środowiska oprogramowania</span><span class="sxs-lookup"><span data-stu-id="4db1f-1050">Entity Framework 5 and 6 Software Environment</span></span>
    -   <span data-ttu-id="4db1f-1051">Nazwa systemu operacyjnego: Windows 8,1 Enterprise</span><span class="sxs-lookup"><span data-stu-id="4db1f-1051">OS Name: Windows 8.1 Enterprise</span></span>
    -   <span data-ttu-id="4db1f-1052">Visual Studio 2013 — wersja Ultimate.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1052">Visual Studio 2013 – Ultimate.</span></span>

##### <a name="11112-hardware-environment"></a><span data-ttu-id="4db1f-1053">Środowisko sprzętowe 11.1.1.2</span><span class="sxs-lookup"><span data-stu-id="4db1f-1053">11.1.1.2      Hardware Environment</span></span>

-   <span data-ttu-id="4db1f-1054">Podwójny procesor:     Intel (R) Xeon (R) procesora CPU L5520 W3530 @ 2,27 GHz, 2261 Mhz8 GHz, 4 rdzenie, 84 procesorów logicznych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1054">Dual Processor:     Intel(R) Xeon(R) CPU L5520 W3530 @ 2.27GHz, 2261 Mhz8 GHz, 4 Core(s), 84 Logical Processor(s).</span></span>
-   <span data-ttu-id="4db1f-1055">2412 GB RamRAM.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1055">2412 GB RamRAM.</span></span>
-   <span data-ttu-id="4db1f-1056">dysk 136 GB SCSI250GB SATA 7200 RPM WŁĄCZONĄ/s podzielony na 4 partycje.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1056">136 GB SCSI250GB SATA 7200 rpm 3GB/s drive split into 4 partitions.</span></span>

#### <a name="1112-db-server"></a><span data-ttu-id="4db1f-1057">Serwer 11.1.2 DB</span><span class="sxs-lookup"><span data-stu-id="4db1f-1057">11.1.2       DB server</span></span>

##### <a name="11121-software-environment"></a><span data-ttu-id="4db1f-1058">Środowisko oprogramowania 11.1.2.1</span><span class="sxs-lookup"><span data-stu-id="4db1f-1058">11.1.2.1      Software Environment</span></span>

-   <span data-ttu-id="4db1f-1059">Nazwa systemu operacyjnego: Windows Server 2008 R28.1 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1059">OS Name: Windows Server 2008 R28.1 Enterprise SP1.</span></span>
-   <span data-ttu-id="4db1f-1060">SQL Server 2008 R22012.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1060">SQL Server 2008 R22012.</span></span>

##### <a name="11122-hardware-environment"></a><span data-ttu-id="4db1f-1061">Środowisko sprzętowe 11.1.2.2</span><span class="sxs-lookup"><span data-stu-id="4db1f-1061">11.1.2.2      Hardware Environment</span></span>

-   <span data-ttu-id="4db1f-1062">Pojedynczy procesor: Intel (R) Xeon (R) procesora CPU L5520 @ 2,27 GHz, 2261 MhzES-1620 0 @ 3.60 GHz, 4 rdzenie, 8 procesorów logicznych.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1062">Single Processor: Intel(R) Xeon(R) CPU L5520  @ 2.27GHz, 2261 MhzES-1620 0 @ 3.60GHz, 4 Core(s), 8 Logical Processor(s).</span></span>
-   <span data-ttu-id="4db1f-1063">824 GB RamRAM.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1063">824 GB RamRAM.</span></span>
-   <span data-ttu-id="4db1f-1064">dysk 465 GB ATA500GB SATA 7200 RPM 6 GB/s podzielony na 4 partycje.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1064">465 GB ATA500GB SATA 7200 rpm 6GB/s drive split into 4 partitions.</span></span>

### <a name="112-b-query-performance-comparison-tests"></a><span data-ttu-id="4db1f-1065">11,2 B. testy porównawcze wydajności zapytań</span><span class="sxs-lookup"><span data-stu-id="4db1f-1065">11.2      B. Query performance comparison tests</span></span>

<span data-ttu-id="4db1f-1066">Model Northwind został użyty do wykonania tych testów.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1066">The Northwind model was used to execute these tests.</span></span> <span data-ttu-id="4db1f-1067">Zostało ono wygenerowane na podstawie bazy danych za pomocą narzędzia Entity Framework Designer.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1067">It was generated from the database using the Entity Framework designer.</span></span> <span data-ttu-id="4db1f-1068">Następnie Poniższy kod został użyty do porównania wydajności opcji wykonywania zapytania:</span><span class="sxs-lookup"><span data-stu-id="4db1f-1068">Then, the following code was used to compare the performance of the query execution options:</span></span>

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a><span data-ttu-id="4db1f-1069">Model 11,3 C. Navision</span><span class="sxs-lookup"><span data-stu-id="4db1f-1069">11.3 C. Navision Model</span></span>

<span data-ttu-id="4db1f-1070">Baza danych systemu Navision to duża baza danych służąca do pokazania systemu Microsoft Dynamics — NAV.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1070">The Navision database is a large database used to demo Microsoft Dynamics – NAV.</span></span> <span data-ttu-id="4db1f-1071">Wygenerowany model koncepcyjny zawiera 1005 zestawów jednostek i 4227 zestawów skojarzeń.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1071">The generated conceptual model contains 1005 entity sets and 4227 association sets.</span></span> <span data-ttu-id="4db1f-1072">Model używany w teście ma wartość "Flat" — nie dodano żadnego dziedziczenia.</span><span class="sxs-lookup"><span data-stu-id="4db1f-1072">The model used in the test is “flat” – no inheritance has been added to it.</span></span>

#### <a name="1131-queries-used-for-navision-tests"></a><span data-ttu-id="4db1f-1073">zapytania 11.3.1 używane dla testów systemu Navision</span><span class="sxs-lookup"><span data-stu-id="4db1f-1073">11.3.1 Queries used for Navision tests</span></span>

<span data-ttu-id="4db1f-1074">Lista zapytań używana z modelem systemu Navision zawiera trzy kategorie Entity SQL zapytań:</span><span class="sxs-lookup"><span data-stu-id="4db1f-1074">The queries list used with the Navision model contains 3 categories of Entity SQL queries:</span></span>

##### <a name="11311-lookup"></a><span data-ttu-id="4db1f-1075">11.3.1.1, wyszukiwanie</span><span class="sxs-lookup"><span data-stu-id="4db1f-1075">11.3.1.1 Lookup</span></span>

<span data-ttu-id="4db1f-1076">Proste zapytanie wyszukiwania bez agregacji</span><span class="sxs-lookup"><span data-stu-id="4db1f-1076">A simple lookup query with no aggregations</span></span>

-   <span data-ttu-id="4db1f-1077">Liczbą 16232</span><span class="sxs-lookup"><span data-stu-id="4db1f-1077">Count: 16232</span></span>
-   <span data-ttu-id="4db1f-1078">Przykład:</span><span class="sxs-lookup"><span data-stu-id="4db1f-1078">Example:</span></span>

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a><span data-ttu-id="4db1f-1079">11.3.1.2 SingleAggregating</span><span class="sxs-lookup"><span data-stu-id="4db1f-1079">11.3.1.2 SingleAggregating</span></span>

<span data-ttu-id="4db1f-1080">Normalne zapytanie analizy biznesowej z wieloma agregacjami, ale bez sum częściowych (pojedyncze zapytanie)</span><span class="sxs-lookup"><span data-stu-id="4db1f-1080">A normal BI query with multiple aggregations, but no subtotals (single query)</span></span>

-   <span data-ttu-id="4db1f-1081">Liczbą 2313</span><span class="sxs-lookup"><span data-stu-id="4db1f-1081">Count: 2313</span></span>
-   <span data-ttu-id="4db1f-1082">Przykład:</span><span class="sxs-lookup"><span data-stu-id="4db1f-1082">Example:</span></span>

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

<span data-ttu-id="4db1f-1083">Gdzie MDF @ no__t-0SessionLogin @ no__t-1Time @ no__t-2Max () jest zdefiniowany w modelu jako:</span><span class="sxs-lookup"><span data-stu-id="4db1f-1083">Where MDF\_SessionLogin\_Time\_Max() is defined in the model as:</span></span>

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a><span data-ttu-id="4db1f-1084">11.3.1.3 AggregatingSubtotals</span><span class="sxs-lookup"><span data-stu-id="4db1f-1084">11.3.1.3 AggregatingSubtotals</span></span>

<span data-ttu-id="4db1f-1085">Zapytanie analizy biznesowej z agregacjami i sumami częściowymi (za pośrednictwem UNION ALL)</span><span class="sxs-lookup"><span data-stu-id="4db1f-1085">A BI query with aggregations and subtotals (via union all)</span></span>

-   <span data-ttu-id="4db1f-1086">Liczbą 178</span><span class="sxs-lookup"><span data-stu-id="4db1f-1086">Count: 178</span></span>
-   <span data-ttu-id="4db1f-1087">Przykład:</span><span class="sxs-lookup"><span data-stu-id="4db1f-1087">Example:</span></span>

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
